
# sklearn 和简单实现
- 核心目标：​​使用一个名为“对数几率回归”（也叫逻辑回归）的模型，根据病人的体检数据，自动预测他/她应该服用哪种药。
![](media/Pasted%20image%2020250903224831.png)



1. 特征化（可能不太对这个概念 大概意思理解一下） / 归一化 / 标准化 ： 把不能用数值表示的 我们进行分组（0-1）的数值表示出来，然后方便我们之后的计算
```
```python

Age,Sex,BP,Cholesterol,Na_to_K,Drug
0-1 0-1 0-1 0-1         0-1    0-1 

Age:   0.2 
    0 ：30 岁以上
    1 ：30 岁以下

Na_K: 0.3
    0-5 :0
    6-10:0.5
    11-15:1
Drug: 
    x: 0
    y: 1

z -- 要算的值
z -- 考虑所有因素后 使用Y的概率

z = 0.2 * age  + 0.3*bp +。。。。

z的值越靠近1 我们就用y
```
2. 选定训练集 / 验证集
    1. 随机选择 一般是80%训练 20%进行验证
3. 然后 使用特定的函数 跑 训练集
    特定的问题 用特定的函数就可以
4. 用验证集 验证我们的 训练模型 成果如何


```python
# 1. 导入必要的库

import pandas as pd

from sklearn.model_selection import train_test_split

from sklearn.linear_model import LogisticRegression

from sklearn.preprocessing import LabelEncoder

  

# 2. 加载数据并筛选两类药物

# 请确保文件路径正确

df = pd.read_csv('rxa.csv')

# 任选两类，这里以 'drugX' 和 'DrugY' 为例

df_binary = df[df['Drug'].isin(['drugX', 'DrugY'])].copy()

  

# 3. 数据预处理：将文字特征转换为数字

# 处理特征 (X)

le_sex = LabelEncoder()

le_bp = LabelEncoder()

le_chol = LabelEncoder()


df_binary['Sex'] = le_sex.fit_transform(df_binary['Sex']) # 例如 F->0, M->1

df_binary['BP'] = le_bp.fit_transform(df_binary['BP'])    # 例如 LOW->0, NORMAL->1, HIGH->2

df_binary['Cholesterol'] = le_chol.fit_transform(df_binary['Cholesterol']) # 例如 NORMAL->0, HIGH->1

  

# 处理标签 (y)

le_drug = LabelEncoder()

df_binary['Drug'] = le_drug.fit_transform(df_binary['Drug']) # 例如 drugX->0, DrugY->1

  

# 4. 准备特征(X)和标签(y)，并划分训练集和测试集

X = df_binary[['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K']]

y = df_binary['Drug']

  

# 随机划分 80% 的数据作为训练集，20% 作为测试集

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

  

# 5. 创建并训练逻辑回归模型

model = LogisticRegression()

model.fit(X_train, y_train)




 

# 6. 评估模型在测试集上的表现

accuracy = model.score(X_test, y_test)

print(f"模型准确率: {accuracy:.2f}")
```




# 使用 PyTorch 实现药物分类预测的完整代码

```
import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from torch.utils.data import Dataset, DataLoader
import matplotlib.pyplot as plt

# 1. 数据加载和预处理
# 加载数据
df = pd.read_csv('drug200.csv')

# 筛选两类药物
df_binary = df[df['Drug'].isin(['drugX', 'DrugY'])].copy()

# 特征编码
le_sex = LabelEncoder()
le_bp = LabelEncoder()
le_chol = LabelEncoder()

df_binary['Sex'] = le_sex.fit_transform(df_binary['Sex'])  # F->0, M->1
df_binary['BP'] = le_bp.fit_transform(df_binary['BP'])     # LOW->0, NORMAL->1, HIGH->2
df_binary['Cholesterol'] = le_chol.fit_transform(df_binary['Cholesterol'])  # NORMAL->0, HIGH->1

# 标签编码
le_drug = LabelEncoder()
df_binary['Drug'] = le_drug.fit_transform(df_binary['Drug'])  # drugX->0, DrugY->1

# 准备特征和标签
X = df_binary[['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K']].values.astype(np.float32)
y = df_binary['Drug'].values.astype(np.float32)

# 2. 划分训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# 3. 创建自定义数据集类
class DrugDataset(Dataset):
    def __init__(self, features, labels):
        self.features = torch.tensor(features, dtype=torch.float32)
        self.labels = torch.tensor(labels, dtype=torch.float32).unsqueeze(1)  # 添加一个维度
    
    def __len__(self):
        return len(self.features)
    
    def __getitem__(self, idx):
        return self.features[idx], self.labels[idx]

# 4. 创建数据集和数据加载器
train_dataset = DrugDataset(X_train, y_train)
test_dataset = DrugDataset(X_test, y_test)

# 创建数据加载器
batch_size = 16
train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)

# 5. 定义逻辑回归模型
class LogisticRegression(nn.Module):
    def __init__(self, input_dim):
        super(LogisticRegression, self).__init__()
        self.linear = nn.Linear(input_dim, 1)  # 输入维度到1个输出
    
    def forward(self, x):
        return torch.sigmoid(self.linear(x))  # 应用sigmoid函数得到概率

# 6. 初始化模型、损失函数和优化器
input_dim = X_train.shape[1]  # 特征数量
model = LogisticRegression(input_dim)
criterion = nn.BCELoss()  # 二分类交叉熵损失
optimizer = optim.Adam(model.parameters(), lr=0.01)  # Adam优化器

# 7. 训练模型
num_epochs = 1000
train_losses = []
test_accuracies = []

for epoch in range(num_epochs):
    # 训练阶段
    model.train()
    total_loss = 0
    for features, labels in train_loader:
        # 前向传播
        outputs = model(features)
        loss = criterion(outputs, labels)
        
        # 反向传播和优化
        optimizer.zero_grad()  # 清除梯度
        loss.backward()        # 计算梯度
        optimizer.step()       # 更新权重
        
        total_loss += loss.item()
    
    avg_train_loss = total_loss / len(train_loader)
    train_losses.append(avg_train_loss)
    
    # 评估阶段
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for features, labels in test_loader:
            outputs = model(features)
            predicted = (outputs > 0.5).float()  # 将概率转换为0或1
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    
    accuracy = correct / total
    test_accuracies.append(accuracy)
    
    # 每100个epoch打印一次损失和准确率
    if (epoch+1) % 100 == 0:
        print(f'Epoch [{epoch+1}/{num_epochs}], Train Loss: {avg_train_loss:.4f}, Test Acc: {accuracy:.4f}')

# 8. 绘制训练过程
plt.figure(figsize=(12, 5))

# 绘制训练损失
plt.subplot(1, 2, 1)
plt.plot(train_losses)
plt.title('Training Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')

# 绘制测试准确率
plt.subplot(1, 2, 2)
plt.plot(test_accuracies)
plt.title('Test Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')

plt.tight_layout()
plt.show()

# 9. 最终评估
model.eval()
with torch.no_grad():
    correct = 0
    total = 0
    for features, labels in test_loader:
        outputs = model(features)
        predicted = (outputs > 0.5).float()
        total += labels.size(0)
        correct += (predicted == labels).sum().item()
    
    accuracy = correct / total
    print(f'最终测试集准确率: {accuracy:.4f}')

# 10. 预测新样本
# 新样本数据：23岁，女性，血压高，胆固醇高，Na_to_K=25.355
new_sample = pd.DataFrame({
    'Age': [23],
    'Sex': ['F'],
    'BP': ['HIGH'],
    'Cholesterol': ['HIGH'],
    'Na_to_K': [25.355]
})

# 对新样本进行预处理
new_sample['Sex'] = le_sex.transform(new_sample['Sex'])
new_sample['BP'] = le_bp.transform(new_sample['BP'])
new_sample['Cholesterol'] = le_chol.transform(new_sample['Cholesterol'])

# 转换为PyTorch张量
new_sample_tensor = torch.tensor(new_sample.values, dtype=torch.float32)

# 使用模型进行预测
model.eval()
with torch.no_grad():
    output = model(new_sample_tensor)
    probability = output.item()
    prediction = 1 if probability > 0.5 else 0

# 将预测结果转换回原始标签
predicted_drug = le_drug.inverse_transform([prediction])[0]
print(f'\n预测结果：该患者应使用药物: {predicted_drug}')
print(f'预测概率: {probability:.4f}')
```

## PyTorch 代码结构详解

### 1. 数据预处理

- 使用 pandas 加载 CSV 数据
- 筛选特定类别的样本（drugX 和 DrugY）
- 使用 LabelEncoder 将分类特征转换为数值
- 将数据转换为 NumPy 数组

### 2. 数据集和数据加载器

- 创建自定义 Dataset 类，继承自 `torch.utils.data.Dataset`
- 实现 `__len__` 和 `__getitem__` 方法
- 使用 DataLoader 创建批量数据加载器，支持打乱顺序和并行加载

### 3. 模型定义

- 创建自定义模型类，继承自 `nn.Module`
- 在 `__init__` 方法中定义网络层
- 在 `forward` 方法中定义前向传播逻辑
- 本例中使用简单的逻辑回归模型（单层线性网络 + sigmoid 激活）

### 4. 训练循环

- 设置模型为训练模式：`model.train()`
- 遍历训练数据加载器
- 前向传播计算输出和损失
- 反向传播计算梯度
- 优化器更新参数
- 记录训练损失

### 5. 评估循环

- 设置模型为评估模式：`model.eval()`
- 禁用梯度计算：`with torch.no_grad():`
- 遍历测试数据加载器
- 计算预测准确率
- 记录测试准确率

### 6. 可视化训练过程

- 绘制训练损失曲线
- 绘制测试准确率曲线
- 使用 matplotlib 创建图表

### 7. 新样本预测

- 创建新样本 DataFrame
- 使用相同的预处理步骤转换特征
- 转换为 PyTorch 张量
- 使用训练好的模型进行预测
- 将数值预测转换回原始标签

## PyTorch 核心概念解释

### 1. 张量 (Tensor)

PyTorch 的基本数据结构，类似于 NumPy 数组但支持 GPU 加速和自动微分。

```
# 创建张量
x = torch.tensor([1, 2, 3], dtype=torch.float32)
y = torch.zeros(3, 2)  # 3行2列的全0张量
z = torch.randn(2, 3)  # 2行3列的正态分布随机数

# 张量运算
a = torch.tensor([1.0, 2.0], requires_grad=True)
b = torch.tensor([3.0, 4.0], requires_grad=True)
c = a * b
d = c.sum()
d.backward()  # 自动计算梯度
print(a.grad)  # 输出 d/da = [3.0, 4.0]
```

### 2. 自动微分 (Autograd)

PyTorch 的核心特性，能够自动计算梯度，简化了反向传播的实现。

```
x = torch.tensor(2.0, requires_grad=True)
y = x**2 + 3*x + 1
y.backward()  # 计算梯度
print(x.grad)  # 输出 dy/dx = 2x + 3 = 7
```

### 3. 神经网络模块 (nn.Module)

所有神经网络模块的基类，自定义模型需要继承这个类。

```
class SimpleNN(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(SimpleNN, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, output_size)
    
    def forward(self, x):
        x = self.fc1(x)
        x = self.relu(x)
        x = self.fc2(x)
        return x
```

### 4. 损失函数 (Loss Functions)

PyTorch 提供了多种损失函数：

- `nn.MSELoss()`: 均方误差损失（回归）
- `nn.CrossEntropyLoss()`: 交叉熵损失（多分类）
- `nn.BCELoss()`: 二分类交叉熵损失
- `nn.BCEWithLogitsLoss()`: 结合 Sigmoid 的二分类交叉熵损失

### 5. 优化器 (Optimizers)

用于更新模型参数以最小化损失函数：

- `optim.SGD`: 随机梯度下降
- `optim.Adam`: 自适应矩估计优化器
- `optim.RMSprop`: RMSprop 优化器

```
model = SimpleNN(10, 5, 1)
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)
```

### 6. 数据集和数据加载器 (Dataset & DataLoader)

PyTorch 提供了高效的数据加载机制。

```
class CustomDataset(Dataset):
    def __init__(self, data, labels):
        self.data = data
        self.labels = labels
    
    def __len__(self):
        return len(self.data)
    
    def __getitem__(self, idx):
        return self.data[idx], self.labels[idx]

dataset = CustomDataset(X, y)
dataloader = DataLoader(dataset, batch_size=32, shuffle=True, num_workers=2)
```

### 7. 设备选择 (CPU/GPU)

PyTorch 可以轻松地在 CPU 和 GPU 之间切换。

```
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = model.to(device)

# 在训练循环中
for inputs, labels in dataloader:
    inputs, labels = inputs.to(device), labels.to(device)
    # ...
```

### 8. 模型保存和加载

保存和加载训练好的模型。

```
# 保存模型
torch.save(model.state_dict(), 'model.pth')

# 加载模型
model = LogisticRegression(input_dim)
model.load_state_dict(torch.load('model.pth'))
model.eval()
```

## 完整代码执行流程

1. ​**​数据准备​**​：加载CSV文件，筛选两类药物，进行特征编码
2. ​**​数据分割​**​：将数据划分为训练集和测试集
3. ​**​创建数据集​**​：定义自定义Dataset类，创建DataLoader
4. ​**​模型定义​**​：创建逻辑回归模型（单层神经网络）
5. ​**​训练准备​**​：选择损失函数和优化器
6. ​**​训练循环​**​：迭代训练模型，记录损失和准确率
7. ​**​评估模型​**​：在测试集上评估模型性能
8. ​**​可视化​**​：绘制训练损失和测试准确率曲线
9. ​**​预测新样本​**​：对新患者数据进行预测

这个完整代码实现了药物分类任务，并展示了PyTorch的核心概念和基本用法。通过这个示例，您可以了解如何使用PyTorch构建、训练和评估一个简单的分类模型。