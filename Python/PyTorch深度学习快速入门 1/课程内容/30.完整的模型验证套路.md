# PyTorch模型验证全流程实战指南

## 一、模型验证核心流程

### 完整验证流程图

```
graph TD
    A[加载训练好的模型] --> B[准备测试数据]
    B --> C[图像预处理]
    C --> D[模型推断]
    D --> E[结果解析]
    E --> F[可视化输出]
```

## 二、模型加载最佳实践

### 设备无关的模型加载

```python
import torch
from models import MyModel  # 导入模型定义

# 智能设备检测
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# 加载模型（兼容CPU/GPU）
model = MyModel()
model.load_state_dict(
    torch.load('best_model.pth', map_location=device)
)
model = model.to(device)
model.eval()  # 切换到评估模式
```

### 处理常见加载问题

```python
# 修复键名不匹配（多GPU训练保存的模型）
state_dict = torch.load('model.pth')
if 'module.' in list(state_dict.keys())[0]:
    # 移除module前缀
    state_dict = {k.replace('module.', ''): v for k, v in state_dict.items()}
model.load_state_dict(state_dict)
```

## 三、图像预处理标准化流程

### 完整预处理管道

```python
from torchvision import transforms
from PIL import Image

# 定义与训练一致的预处理
transform = transforms.Compose([
    transforms.Resize(256),  # 调整尺寸
    transforms.CenterCrop(224),  # 中心裁剪
    transforms.ToTensor(),  # 转为Tensor
    transforms.Normalize(  # 归一化
        mean=[0.485, 0.456, 0.406],
        std=[0.229, 0.224, 0.225]
    )
])

# 加载并预处理图像
image_path = "test_images/dog.jpg"
image = Image.open(image_path).convert('RGB')
input_tensor = transform(image)

# 添加批次维度
input_batch = input_tensor.unsqueeze(0).to(device)
```

## 四、模型推断与结果解析

### 高效推断实现

```python
# 禁用梯度计算
with torch.no_grad():
    # 执行推断
    output = model(input_batch)
    
    # 获取预测结果
    probabilities = torch.nn.functional.softmax(output[0], dim=0)
    predicted_class_idx = torch.argmax(probabilities).item()
    confidence = probabilities[predicted_class_idx].item()
```

### 类别映射与结果展示

```python
# 类别标签映射
class_names = ['飞机', '汽车', '鸟', '猫', '鹿', '狗', '青蛙', '马', '船', '卡车']

# 输出结果
print(f"预测类别: {class_names[predicted_class_idx]}")
print(f"置信度: {confidence*100:.2f}%")

# 获取Top-3预测结果
top3_prob, top3_catid = torch.topk(probabilities, 3)
for i in range(top3_prob.size(0)):
    print(f"{class_names[top3_catid[i]]}: {top3_prob[i].item()*100:.2f}%")
```

## 五、可视化增强技术

### 带置信度的图像标注

```python
import matplotlib.pyplot as plt

def visualize_prediction(image, prediction, confidence):
    plt.figure(figsize=(10, 8))
    plt.imshow(image)
    plt.title(f"预测: {prediction} ({confidence*100:.2f}%)", fontsize=16)
    plt.axis('off')
    plt.savefig('prediction_result.jpg')
    plt.show()

# 使用示例
visualize_prediction(image, class_names[predicted_class_idx], confidence)
```

### 类激活热力图

```python
from torchcam.methods import GradCAM
from torchcam.utils import overlay_mask

# 初始化GradCAM
cam_extractor = GradCAM(model, target_layer="layer4.2.conv3")

# 获取激活图
activation_map = cam_extractor(predicted_class_idx, output)

# 叠加热力图
result = overlay_mask(
    transforms.functional.to_pil_image(input_tensor),
    transforms.functional.to_pil_image(activation_map[0].squeeze(0), mode='F'),
    alpha=0.5
)

# 保存结果
result.save('heatmap_result.jpg')
```

## 六、批量验证与性能评估

### 完整测试集评估

```python
def evaluate_model(model, test_loader, device):
    model.eval()
    correct = 0
    total = 0
    
    with torch.no_grad():
        for images, labels in test_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    
    accuracy = 100 * correct / total
    print(f'测试集准确率: {accuracy:.2f}%')
    return accuracy

# 使用示例
test_loader = ...  # 创建测试数据加载器
accuracy = evaluate_model(model, test_loader, device)
```

### 混淆矩阵分析

```python
from sklearn.metrics import confusion_matrix
import seaborn as sns

def plot_confusion_matrix(model, test_loader, device, class_names):
    model.eval()
    all_preds = []
    all_labels = []
    
    with torch.no_grad():
        for images, labels in test_loader:
            images = images.to(device)
            outputs = model(images)
            _, preds = torch.max(outputs, 1)
            all_preds.extend(preds.cpu().numpy())
            all_labels.extend(labels.numpy())
    
    # 计算混淆矩阵
    cm = confusion_matrix(all_labels, all_preds)
    
    # 可视化
    plt.figure(figsize=(10, 8))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', 
                xticklabels=class_names, yticklabels=class_names)
    plt.xlabel('预测标签')
    plt.ylabel('真实标签')
    plt.title('混淆矩阵')
    plt.savefig('confusion_matrix.png')
    plt.show()
```

## 七、部署优化技巧

### ONNX格式导出

```python
# 导出为ONNX格式
dummy_input = torch.randn(1, 3, 224, 224).to(device)
torch.onnx.export(
    model,
    dummy_input,
    "model.onnx",
    input_names=["input"],
    output_names=["output"],
    dynamic_axes={'input': {0: 'batch_size'}, 'output': {0: 'batch_size'}}
)
```

### TensorRT加速

```python
# 转换为TensorRT引擎
import tensorrt as trt

logger = trt.Logger(trt.Logger.WARNING)
builder = trt.Builder(logger)
network = builder.create_network(1 << int(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH))
parser = trt.OnnxParser(network, logger)

with open("model.onnx", "rb") as f:
    parser.parse(f.read())

config = builder.create_builder_config()
config.set_memory_pool_limit(trt.MemoryPoolType.WORKSPACE, 1 << 30)
engine = builder.build_engine(network, config)
```

## 八、调试与错误处理

### 常见问题解决方案

|问题|原因|解决方案|
|---|---|---|
|​**​尺寸不匹配​**​|输入尺寸与模型不匹配|检查预处理步骤|
|​**​预测结果错误​**​|类别映射错误|验证标签顺序|
|​**​内存不足​**​|大尺寸图像|减小批次大小|
|​**​设备不匹配​**​|模型/数据在不同设备|统一使用`.to(device)`|
|​**​预处理不一致​**​|训练/验证预处理不同|统一预处理流程|

### 调试检查点

```python
# 验证输入输出
print("输入尺寸:", input_batch.shape)
print("输出尺寸:", output.shape)

# 检查设备
print("模型设备:", next(model.parameters()).device)
print("输入设备:", input_batch.device)

# 检查预处理
plt.imshow(input_tensor.permute(1, 2, 0).cpu().numpy())
plt.title("预处理后图像")
plt.show()
```

## 九、完整验证脚本示例

```python
import torch
from torchvision import transforms, datasets
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np

# 配置
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
class_names = ['飞机', '汽车', '鸟', '猫', '鹿', '狗', '青蛙', '马', '船', '卡车']

# 1. 加载模型
model = torch.load('model.pth', map_location=device)
model.eval()

# 2. 预处理管道
transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

# 3. 单张图像推断
def predict_image(image_path):
    img = Image.open(image_path)
    input_tensor = transform(img)
    input_batch = input_tensor.unsqueeze(0).to(device)
    
    with torch.no_grad():
        output = model(input_batch)
        probabilities = torch.nn.functional.softmax(output[0], dim=0)
        pred_idx = torch.argmax(probabilities).item()
        confidence = probabilities[pred_idx].item()
    
    # 可视化
    plt.figure(figsize=(10, 8))
    plt.imshow(img)
    plt.title(f"预测: {class_names[pred_idx]} ({confidence*100:.2f}%)", fontsize=16)
    plt.axis('off')
    plt.savefig('prediction_result.jpg')
    plt.show()
    
    return class_names[pred_idx], confidence

# 4. 测试集评估
def evaluate_test_set():
    test_dataset = datasets.ImageFolder('test_data', transform=transform)
    test_loader = torch.utils.data.DataLoader(test_dataset, batch_size=32, shuffle=True)
    
    correct = 0
    total = 0
    with torch.no_grad():
        for images, labels in test_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    
    accuracy = 100 * correct / total
    print(f'测试集准确率: {accuracy:.2f}%')
    return accuracy

# 执行验证
image_pred, confidence = predict_image("test_images/dog.jpg")
test_accuracy = evaluate_test_set()
```

> ​**​最佳实践建议​**​：将验证流程封装为独立函数或类，便于集成到更大系统中。对于生产环境，建议添加日志记录和异常处理机制，确保稳定运行。