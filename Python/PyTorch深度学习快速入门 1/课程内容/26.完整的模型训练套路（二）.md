# PyTorch模型评估与可视化全流程实战指南

## 一、模型评估核心流程

### 测试阶段关键代码模板

```python
def evaluate(model, test_loader, device):
    model.eval()  # 切换到评估模式
    test_loss = 0.0
    correct = 0
    total = 0
    
    with torch.no_grad():  # 禁用梯度计算
        for inputs, targets in test_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            
            # 前向传播
            outputs = model(inputs)
            
            # 计算损失
            loss = criterion(outputs, targets)
            test_loss += loss.item()
            
            # 计算准确率
            _, predicted = outputs.max(1)  # 获取预测类别
            total += targets.size(0)
            correct += predicted.eq(targets).sum().item()
    
    # 计算整体指标
    avg_loss = test_loss / len(test_loader)
    accuracy = 100. * correct / total
    
    return avg_loss, accuracy
```

## 二、TensorBoard可视化实战

### 日志记录配置

```python
from torch.utils.tensorboard import SummaryWriter

# 初始化Writer
writer = SummaryWriter('logs/experiment1')

# 训练循环中记录
for epoch in range(epochs):
    # ...训练代码...
    
    # 记录训练指标
    writer.add_scalar('Loss/train', train_loss, epoch)
    writer.add_scalar('Accuracy/train', train_acc, epoch)
    
    # 记录测试指标
    test_loss, test_acc = evaluate(model, test_loader, device)
    writer.add_scalar('Loss/test', test_loss, epoch)
    writer.add_scalar('Accuracy/test', test_acc, epoch)
    
    # 记录学习率
    writer.add_scalar('Learning Rate', optimizer.param_groups[0]['lr'], epoch)
    
    # 记录模型权重分布
    for name, param in model.named_parameters():
        writer.add_histogram(f'{name}', param, epoch)
```

### 可视化分析技巧

```python
# 启动TensorBoard
tensorboard --logdir=logs/experiment1
```

#### 关键图表解读：

1. ​**​Loss曲线对比​**​：训练损失持续下降而测试损失上升 → ​**​过拟合​**​
    
2. ​**​Accuracy曲线​**​：测试准确率远低于训练准确率 → ​**​泛化能力差​**​
    
3. ​**​权重分布​**​：权重值接近0 → ​**​神经元死亡​**​
    

## 三、模型保存策略优化

### 智能保存机制

```python
best_acc = 0.0

for epoch in range(epochs):
    # ...训练和评估...
    
    # 保存最新模型
    torch.save({
        'epoch': epoch,
        'model_state_dict': model.state_dict(),
        'optimizer_state_dict': optimizer.state_dict(),
        'loss': train_loss,
        'accuracy': test_acc
    }, f'checkpoints/latest.pth')
    
    # 保存最佳模型
    if test_acc > best_acc:
        best_acc = test_acc
        torch.save(model.state_dict(), f'checkpoints/best_model_acc{test_acc:.2f}.pth')
        print(f"🔥 新最佳模型保存: 准确率 {test_acc:.2f}%")
```

### 模型加载与恢复

```python
def load_model(model, optimizer=None, path='checkpoints/latest.pth'):
    checkpoint = torch.load(path)
    model.load_state_dict(checkpoint['model_state_dict'])
    
    if optimizer:
        optimizer.load_state_dict(checkpoint['optimizer_state_dict'])
    
    print(f"✅ 模型加载成功 (epoch {checkpoint['epoch']}, acc {checkpoint['accuracy']:.2f}%)")
    return model, optimizer
```

## 四、分类性能深度分析

### 混淆矩阵实现

```python
from sklearn.metrics import confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

def plot_confusion_matrix(model, test_loader, device):
    model.eval()
    all_preds = []
    all_targets = []
    
    with torch.no_grad():
        for inputs, targets in test_loader:
            inputs = inputs.to(device)
            outputs = model(inputs)
            _, preds = outputs.max(1)
            all_preds.extend(preds.cpu().numpy())
            all_targets.extend(targets.numpy())
    
    # 计算混淆矩阵
    cm = confusion_matrix(all_targets, all_preds)
    
    # 可视化
    plt.figure(figsize=(10,8))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
    plt.xlabel('预测标签')
    plt.ylabel('真实标签')
    plt.title('混淆矩阵')
    plt.savefig('confusion_matrix.png')
    plt.close()
```

### 类别级准确率分析

```python
def class_accuracy(model, test_loader, device, num_classes=10):
    class_correct = [0] * num_classes
    class_total = [0] * num_classes
    
    model.eval()
    with torch.no_grad():
        for inputs, targets in test_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            outputs = model(inputs)
            _, predicted = outputs.max(1)
            
            c = predicted.eq(targets)
            for i in range(targets.size(0)):
                label = targets[i]
                class_correct[label] += c[i].item()
                class_total[label] += 1
    
    # 打印结果
    for i in range(num_classes):
        acc = 100 * class_correct[i] / class_total[i] if class_total[i] > 0 else 0
        print(f'类别 {i}: {acc:.2f}% ({class_correct[i]}/{class_total[i]})')
    
    return class_correct, class_total
```

## 五、高级评估技术

### ROC曲线与AUC计算

```python
from sklearn.metrics import roc_curve, auc

def plot_roc_curve(model, test_loader, device, class_idx):
    model.eval()
    y_true = []
    y_score = []
    
    with torch.no_grad():
        for inputs, targets in test_loader:
            inputs = inputs.to(device)
            outputs = model(inputs)
            probas = F.softmax(outputs, dim=1)
            
            y_true.extend((targets == class_idx).numpy())
            y_score.extend(probas[:, class_idx].cpu().numpy())
    
    # 计算ROC
    fpr, tpr, _ = roc_curve(y_true, y_score)
    roc_auc = auc(fpr, tpr)
    
    # 绘图
    plt.figure()
    plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC曲线 (AUC = {roc_auc:.2f})')
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlabel('假正率')
    plt.ylabel('真正率')
    plt.title(f'类别 {class_idx} 的ROC曲线')
    plt.legend(loc="lower right")
    plt.savefig(f'roc_class_{class_idx}.png')
    plt.close()
```

### 特征可视化

```python
# 可视化卷积特征
def visualize_features(model, test_loader, device):
    # 注册钩子
    features = []
    def hook(module, input, output):
        features.append(output)
    
    model.layer4[2].register_forward_hook(hook)  # 选择特定层
    
    # 获取特征
    model.eval()
    with torch.no_grad():
        for inputs, _ in test_loader:
            inputs = inputs.to(device)
            _ = model(inputs)
            break  # 只取一个批次
    
    # 可视化
    feature_maps = features[0][0].cpu()  # 取第一个样本
    plt.figure(figsize=(12, 8))
    for i in range(16):  # 显示前16个特征图
        plt.subplot(4, 4, i+1)
        plt.imshow(feature_maps[i], cmap='viridis')
        plt.axis('off')
    plt.savefig('feature_maps.png')
    plt.close()
```

## 六、生产环境部署

### ONNX导出与推理

```python
# 导出模型
torch.onnx.export(
    model, 
    dummy_input, 
    "model.onnx",
    input_names=["input"],
    output_names=["output"],
    dynamic_axes={'input': {0: 'batch_size'}, 'output': {0: 'batch_size'}}
)

# ONNX推理
import onnxruntime as ort

ort_session = ort.InferenceSession("model.onnx")
inputs = {ort_session.get_inputs()[0].name: input_array}
outputs = ort_session.run(None, inputs)
```

### Flask API服务

```python
from flask import Flask, request, jsonify
from PIL import Image
import numpy as np

app = Flask(__name__)
model = ... # 加载训练好的模型

@app.route('/predict', methods=['POST'])
def predict():
    # 接收图像
    file = request.files['image']
    img = Image.open(file.stream).convert('RGB')
    
    # 预处理
    img = transform(img).unsqueeze(0)
    
    # 推理
    with torch.no_grad():
        output = model(img)
        probs = F.softmax(output, dim=1)
        _, pred = output.max(1)
    
    # 返回结果
    return jsonify({
        'class': int(pred.item()),
        'confidence': float(probs[0, pred].item()),
        'probabilities': probs.numpy().tolist()[0]
    })
```

## 七、评估报告生成

### 自动生成评估报告

```python
def generate_report(model, test_loader, device):
    # 计算指标
    test_loss, test_acc = evaluate(model, test_loader, device)
    class_correct, class_total = class_accuracy(model, test_loader, device)
    
    # 生成报告
    report = f"""
    ============== 模型评估报告 ==============
    测试损失: {test_loss:.4f}
    整体准确率: {test_acc:.2f}%
    
    ------------ 类别级准确率 ------------
    """
    for i in range(len(class_correct)):
        acc = 100 * class_correct[i] / class_total[i] if class_total[i] > 0 else 0
        report += f"类别 {i}: {acc:.2f}% ({class_correct[i]}/{class_total[i]})\n"
    
    report += "======================================="
    
    # 保存报告
    with open('evaluation_report.txt', 'w') as f:
        f.write(report)
    
    return report
```

## 八、最佳实践总结

### 模型评估检查表

|步骤|关键点|工具/方法|
|---|---|---|
|测试准备|禁用梯度计算|`with torch.no_grad()`|
|指标计算|整体损失和准确率|`evaluate()`函数|
|性能分析|类别级表现|混淆矩阵/ROC曲线|
|可视化|训练过程监控|TensorBoard|
|模型保存|最佳模型保留|智能保存策略|
|部署准备|格式转换|ONNX导出|
|报告生成|全面评估|自动报告生成|

### 性能优化技巧

1. ​**​混合精度评估​**​：
    
    ```python
    with torch.cuda.amp.autocast():
        outputs = model(inputs)
    ```
    
2. ​**​批量推理加速​**​：
    
    ```python
    # 增加批量大小
    test_loader = DataLoader(test_set, batch_size=512)
    ```
    
3. ​**​异步数据加载​**​：
    
    ```python
    test_loader = DataLoader(test_set, batch_size=128, num_workers=4, pin_memory=True)
    ```
    
4. ​**​模型剪枝​**​：
    
    ```python
    from torch.nn.utils import prune
    prune.l1_unstructured(model.conv1, name='weight', amount=0.2)
    ```
    

> ​**​终极建议​**​：使用PyTorch Lightning或Hugging Face Accelerate库简化评估流程，这些框架提供了内置的评估和可视化工具，大幅提升开发效率。