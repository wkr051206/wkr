## 1 综合运用继承与多态的知识
```Java
package org.example;  
  
class A {  
    public void method1() {  
        System.out.println("invoke A method1");  
    }  
    public void method2() {  
        method1();  
    }  
}  
  
class B extends A {  
    public void method3() {  
        System.out.println("invoke B method3");  
    }  
}  
  
class C {  
    public static void main(String[] args) {  
        B b = new B();  
        A a = b;          // 向上类型转换（Upcasting）  
        callA(a);  
        callA(new B());  
    }  
  
    // 将callA方法定义为类C的静态方法  
    public static void callA(A a) {  
        B b = (B) a;     // 强制类型转换（Downcasting）  
        b.method1();  
        b.method2();  
        b.method3();  
    }  
}
```
**关于 class C中的内容
让我用更简单的方式来解释！

🍎 用"水果"的比喻来理解

想象一下：

- •
    
    **类A**​ = **水果**（有颜色、重量等属性）
    
- •
    
    **类B**​ = **苹果**（继承水果，还有"甜度"这个特有属性）
    
- •
    
    **类C**​ = **水果店老板**（负责处理水果）
    

```
class C { // 水果店老板
    public static void main(String[] args) { 
        // 老板拿到一个具体的苹果
        苹果 具体苹果 = new 苹果();     // B b = new B();
        
        // 老板说："我把这个苹果当作普通水果来处理"
        水果 当作水果的苹果 = 具体苹果;  // A a = b; （向上转型）
        
        // 老板检查这个"当作水果的苹果"
        检查水果(当作水果的苹果);       // callA(a);
        
        // 老板直接拿一个新苹果检查
        检查水果(new 苹果());          // callA(new B());
    } 
}
```

**🔄 向上转型的简单理解

**向上转型 = "把具体的东西当作一般的东西看待"**

例子：

- •
    
    把"苹果"当作"水果" ✅（苹果是水果的一种）
    
- •
    
    把"狗"当作"动物" ✅
    
- •
    
    把"汽车"当作"交通工具" ✅
    

```
// 这就像说：
苹果 我的苹果 = new 苹果();
水果 某个水果 = 我的苹果; // ✅ 完全合理！苹果就是水果
```

❓ 为什么要这样做？

**场景1：写一个通用的方法

```
// 如果只能处理具体类型：
void 检查苹果(苹果 a) { ... }
void 检查香蕉(香蕉 b) { ... }
void 检查橙子(橙子 o) { ... }
// 要写很多很多方法！

// 如果使用向上转型：
void 检查水果(水果 f) { // 一个方法处理所有水果
    if (f instanceof 苹果) {
        苹果 a = (苹果) f; // 向下转型回苹果
        a.检查甜度();      // 调用苹果特有的方法
    }
    // 通用的水果检查...
}
```

**场景2：放在同一个篮子里

```
List<水果> 水果篮 = new ArrayList<>();
水果篮.add(new 苹果());    // 向上转型：苹果→水果
水果篮.add(new 香蕉());    // 向上转型：香蕉→水果  
水果篮.add(new 橙子());    // 向上转型：橙子→水果

// 可以统一处理所有水果
for (水果 f : 水果篮) {
    检查水果(f);
}
```

**🎯 你代码的具体流程

```
public static void main(String[] args) { 
    // 1. 创建一个具体的B对象（就像买一个具体的苹果）
    B b = new B();
    
    // 2. 把这个B对象当作A类型来看待（把苹果当作水果）
    A a = b; // 向上转型
    
    // 3. 把"当作A的B对象"交给callA方法处理
    callA(a); 
    
    // 4. 直接创建新B对象交给callA（自动向上转型）
    callA(new B()); 
}
```

**💡 核心思想总结

1. 1.
    
    **向上转型是安全的**：因为苹果一定是水果，B一定是A
    
2. 2.
    
    **为了代码的灵活性**：一个方法可以处理各种子类
    
3. 3.
    
    **体现面向对象思想**：关注"是什么"（水果），而不是"具体是什么"（苹果/香蕉/橙子）
    

**简单说：向上转型就是"把具体当一般"，让代码更通用、更灵活！**

这样理解是不是更清楚一些？😊

## 2 Circle类的封装与构造方法实现
编程创建一个类 Circle，其中具有 2个变量(半径 radius 和面积 area)、2 个构造函数(Circle()和 Circle(int radius)、2 个方法getArea()和main()请在 main 方法中分别使用不同构造函数创建方法，并打印其面积。



### 解题思路

1. **理解类结构**：Circle类需要包含两个成员变量（半径radius和面积area）、两个构造函数（无参和带参）、两个方法（getArea()和main()）。
    
2. **变量设计**：radius和area应定义为私有变量，以确保数据封装。area的值应基于radius计算，而不是独立设置，以避免数据不一致。
    
3. **构造函数**：
    
    - 无参构造函数Circle()：设置默认半径（如0），并计算对应面积。
        
    - 带参构造函数Circle(int radius)：使用传入的半径值，并计算面积。
        
    
4. **方法实现**：
    
    - getArea()：返回area的值。
        
    - main()方法：演示如何使用不同构造函数创建对象，并调用getArea()打印面积。
        
    
5. **面积计算**：使用公式 area=π×radius2，其中π用Math.PI表示。
    

### 完整代码实现

```
public class Circle {
    // 定义私有变量
    private double radius;
    private double area;

    // 无参构造函数
    public Circle() {
        this.radius = 0;  // 默认半径为0
        this.area = Math.PI * radius * radius; // 计算面积
    }

    // 带参构造函数
    public Circle(int radius) {
        this.radius = radius;
        this.area = Math.PI * radius * radius; // 根据半径计算面积
    }

    // 获取面积的方法
    public double getArea() {
        return area;
    }

    // 主方法
    public static void main(String[] args) {
        // 使用无参构造函数创建对象
        Circle circle1 = new Circle();
        System.out.println("无参构造函数创建的圆面积: " + circle1.getArea());

        // 使用带参构造函数创建对象（例如半径为5）
        Circle circle2 = new Circle(5);
        System.out.println("带参构造函数创建的圆面积: " + circle2.getArea());
    }
}
```

### 代码解释

- **变量**：radius和area被声明为private，遵循封装原则。
    
- **构造函数**：每个构造函数都会计算area，确保面积与半径同步。
    
- **main方法**：创建两个Circle对象（一个默认半径0，一个半径5），并打印它们的面积。输出示例：
    
    - 无参构造函数创建的圆面积: 0.0
        
    - 带参构造函数创建的圆面积: 78.53981633974483
        
    

这个实现满足了题目要求，并体现了Java面向编程的基本概念。如果有疑问，可以进一步讨论！

## 3
```java
// 在Inner类的innerMethod方法中
void innerMethod() {
    System.out.println("outer num = " + Outer.this.num);  // (1) 补全
    System.out.println("you are calling the inner method");
}

// 在Outer类的accessFromInside方法中
public void accessFromInside() {
    Outer.Inner in = new Inner();  // (2) 补全
    System.out.println("access the inner class in outer class");
    in.innerMethod();
    int value = in.i;  // (3) 补全
    System.out.println("inner field i = " + value);
}

// 在Test类的accessFromOuter方法中
void accessFromOuter() {
    Outer out = new Outer();
    Outer.Inner in3 = out.new Inner();  // (4) 补全（注意：原代码中的"lInner"应为"Inner"，可能是笔误）
    System.out.println("access the inner class in other class");
    in3.innerMethod();  // 注意：原代码中为"in3.lInnerMethod()"，应为"in3.innerMethod()"
}
```