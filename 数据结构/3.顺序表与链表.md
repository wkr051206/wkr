## 线性表

***由n（>=0)个数据特性相同的元素构成的有限序列，称为线性表

***线性表中元素的个数n定义为线性表的长度，当n=0时称之为空表。

***对于非空的线性表或线性结构，其特点是：

存在唯一的一个被称作“第一个”的数据元素；
存在唯一的一个被称作“最后一个”的数据元素;
除第一个元素外, 结构中的每个数据元素均只有一个前驱;
除最后一个元素外, 结构中的每个数据元素均只有一个后继。
![](media/Pasted%20image%2020251016105629.png)
```c
#include<stdio.h>
#include<string.h>

struct book{
int isbn;
char bookName[20];
double price;
}

int main(int argc,char const *argv[])
{
book b;
b.isbn=767645;
strcpy(b.bookName,"Java编程思想");
b.price=90;
return 0;
}
```

## 顺序表

用一组连续的内存单元依次存储线性表的各个元素，也就是说，逻辑上相邻的元素，实际的物理存储空间也是连续的。

**顺序表-存储结构**

```c
#define MAXSIZE=100;
##定义符号常量 MAXSIZE 的值为 100(使用宏定义的好处是，如果需要修改顺序表的最大容量（比如改成200），只需要修改这一处即可，非常方便且不易出错。)
typedef int ElemType;

typedef struct{
   ElemType data[MAXSIZE];
   int length;
}SeqList;
```

完整版
```c
//1、编写函数创建一张空的顺序表L，将ajcniydu存储到顺序表中。
#include <stdio.h>
#include <string.h>
#define MAXSIZE 100
typedef int ElemType;
  
typedef struct {
   ElemType data[MAXSIZE];
} SeqList;

int main() {
    SeqList L;
    char str[] = "ajcniydu";  // 要存储的字符串
    // 将字符串存储到顺序表中
    for(int i = 0; i < strlen(str); i++) {
    // 解释：这是一个循环，从第一个字符开始，到最后一个字符结束 
    // strlen(str)计算字符串长度，结果是8 
    // i从0到7，分别对应8个字符的位置
        L.data[i] = str[i];  // 存储字符的ASCII码
    }
    for(int i = 0; i < L.length; i++) {
        printf("%c ", L.data[i]);
        // 解释：将ASCII码数字转换回字符格式打印 
        // %c表示以字符格式打印 
        // (char)是将int类型强制转换为char类型 
        // 例如：L.data[0]的值是97，转换为字符就是'a'
    }
    return 0;
}
```
***顺序表-在尾部添加元素
```c
int appendElem(SeqList *L,ElemType e) // 定义函数：向顺序表L追加元素e
  // appendElem：向顺序表尾部追加元素​
  //`SeqList *L`：指向顺序表结构的指针，用于修改表内容。
  //`ElemType e`：要添加的元素，类型由 `ElemType`定义（如 `int`、`char`等）
{
    if(L->length>=MAXSIZE)
    //`L->length`是当前表长（元素个数）
    //`MAXSIZE`是表的最大容量（常量）
    {
      printf("顺序表已满\n");
      return 0;
    }
    L->data[L->length]=e;//若表未满，将元素 `e`存入数组末尾
    //`L->data`是存储元素的数组
    //`L->length`是当前最后一个元素的​**​下一个位置索引​**​（因为索引从0开始）
    L->length++;
    return 1;
}
```

***顺序表-遍历

```c
void listElem(SeqList *L)// 定义函数：打印顺序表的所有元素
{
   for (int i=0;i<L->length;i++)// 循环：从0到表长-1遍历每个元素
   {
      printf("%d",L->data[i]);//`L->data[i]`：访问第i个位置的元素
   }
   printf("\n");// 所有元素打印完后换行
}
```

***顺序表-插入元素

![](media/Pasted%20image%2020251020170829.png)
                                                                        
![](media/Pasted%20image%2020251020170847.png)
```c
int insertElem(SeqList *L,int pos,ElemType e)// 在顺序表指定位置插入元素 
{
    if(pos<=L->length)// 检查插入位置是否有效（1 ≤ pos ≤ length+1）
    {
       // 从最后一个元素开始，到插入位置前的元素，依次向后移动一位
       for(int i=L->length-1;i>=pos-1;i--)
       {
       L->data[i+1]=L->data[i];// 将当前元素复制到后一个位置
       }
    L->data[pos-1]=e;// 在腾出的位置放入新元素
    L->length++;
    }// 表长增加1
  return 1;// 总是返回1（即使插入失败）
}
```

```
**元素移动 (`for`循环)​**​

- ​**​逻辑​**​：如果位置有效，函数通过循环将元素向后移动一位，腾出空间给新元素。
    
    - `for(int i = L->length - 1; i >= pos - 1; i--)`:
        
        - `i`从最后一个元素的索引（`L->length - 1`）开始，递减到 `pos - 1`（插入位置的索引）。
            
        - 例如，如果 `length = 5`，`pos = 3`，则循环从 `i = 4`（索引 4）到 `i = 2`（索引 2），移动元素。
            
        
    - `L->data[i + 1] = L->data[i]`: 将当前元素复制到后一个位置，实现向后移动。
        
    
- ​**​正确性​**​：这部分逻辑正确，但前提是位置有效且表未满。索引计算基于 `pos - 1`，因为顺序表通常从索引 0 开始存储（位置 1 对应索引 0）。
```

***顺序表-删除元素

```c
int deleteElem(SeqList *L,int pos,ElemType *e)
//`ElemType *e`：用于返回被删除元素的指针
{
  *e=L->data[pos-1];// 保存被删除元素的值
  if(pos<L->length)// 如果不是删除最后一个元素
{
     for(int i=pos;i<L->length;i++)
     {
        L->data[i-1]=L->data[i];// 元素前移
     }
}
   L->length--;// 更新表长
   return 1;// 返回成功
}
```

***顺序表-查找

```c
int findElem(SeqList *L,ElemType e)
{
    for(int i=0;i<L->length;i++)
    {
       if(L->data[i]==e)
       {
          return i+1;
       }
    }
    return 0;
}
```

***顺序表-动态分配内存地址初始化
```c
typedef struct{
    ElemType *data;// 指向动态分配数组的指针
    int length;// 当前顺序表中元素的数量
}SeqList;

SeqList* initList(SeqList *L)
{
    SeqList *L=(SeqList*)malloc(sizeof(SeqList));//在堆内存中分配一个新的 `SeqList`结构体
    L->data=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);//为顺序表的元素数组分配内存
    L->length=0;//初始化顺序表长度为 0,表示当前是空表（无元素）
    return L;//返回新创建的顺序表指针
}(有问题)
```

## 链表

线性表链式存储结构的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。

为了表示每个数据元素 aᵢ 与其直接后继数据元素 aᵢ₊₁ 之间的逻辑关系，对数据元素 aᵢ 来说，除了其本身的信息之外，还需要存储一个指示其直接后继的信息（直接后继的存储位置）。这两部分信息组成数据元素 aᵢ 的存储映像，称为节点（node）。

结点包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。

n 个结点（aᵢ 的存储映像，1≤i≤n）链接成一个链表，即为线性表（a₁, a₂, ..., aₙ）。

**链表存储结构**

```c
typedef int ElemType;

typedef struct node{
   ElemType data;// 存储链表结点的实际数据
   //`data`：结点的数据域，类型为 `ElemType`（当前是 `int`）
   struct node *next;// 指向下一个结点的指针
   //`next`：结点的指针域，指向下一个相同类型的结点（`struct node`）。
}Node;
```
![](media/Pasted%20image%2020251028145609.png)
![](media/Pasted%20image%2020251028150003.png)

**单链表-初始化

![](media/Pasted%20image%2020251028151245.png)

关于疑问：我还是不太理解为什么main函数里面要写这个
非常好！你问到了最核心的问题。下面我用一个非常形象的比喻来解释，为什么 `main`函数里要写 `Node *list = initList();`这一行。

### 核心比喻：​**​建房子 vs. 拿钥匙​**​

想象一下你要住进一所房子：

1. ​**​`initList()`函数就像一个专业的施工队。​**​
    
    - 它的任务是：找一块空地 (`malloc`)，按照图纸 (`sizeof(Node)`) 盖好房子的地基和框架（一个 `Node`结构体），然后把房子内部整理好（`data=0`, `next=NULL`）。
        
    - 最后，施工队把这座新房子的​**​钥匙​**​交给你。
        
    
2. ​**​`Node *list`就是你手里的“钥匙”。​**​
    
    - 这把钥匙很特别，它上面写着地址，能打开特定房子的门。在编程中，这就是​**​指针​**​。`list`这个指针变量，存储着那个新创建的节点在内存中的地址。
        
    
3. ​**​`Node *list = initList();`这行代码的完整过程是：​**​
    
    - ​**​右边 `initList()`​**​：呼叫施工队去干活。施工队干完活后，把新房子的钥匙递给你。
        
    - ​**​左边 `Node *list =`​**​：你伸手接过这把钥匙，并把它妥善地放好，贴上标签叫 `list`。
        
    

---

### 为什么不能直接在 `main`函数里“盖房子”？

你可能会想，为什么不把施工队的活儿（`malloc`、初始化）直接写在 `main`函数里呢？像这样：

```
int main() {
    Node *list = (Node*)malloc(sizeof(Node)); // 自己动手盖房
    list->data = 0;
    list->next = NULL;
    // ... 其他代码
}
```

​**​答案是：可以，但不好。​**​ 这就像每次你要住房子，都自己亲自去画图纸、搬砖头。而使用 `initList()`函数的好处是：

1. ​**​封装与复用（主要目的）​**​
    
    - ​**​简化 `main`函数​**​：`main`函数是程序的“总指挥”，它应该关注更高层的逻辑（比如“创建一个链表”），而不是底层细节（比如怎么分配内存、怎么初始化字段）。`initList()`把脏活累活都包了，`main`函数只需要下命令就行。
        
    - ​**​避免重复代码​**​：如果你的程序需要创建10个链表，难道你要把 `malloc`和初始化的代码写10遍吗？有了 `initList()`，你只需要调用它10次即可，代码简洁又不易出错。
        
    - ​**​统一管理​**​：如果将来你想改变初始化逻辑（比如想把 `data`初始化为 -1），你只需要修改 `initList()`这一个地方，所有调用它的地方都会自动更新。
        
    
2. ​**​概念清晰​**​
    
    - `initList()`这个函数名本身就像一句清晰的指令——“初始化链表”，这让代码读起来更容易理解。
        
    

### 总结与图示

所以，`main`函数里写 `Node *list = initList();`的真正原因是：

​**​为了获得一个可以使用的、合法的链表起点（头结点）。​**​

执行完这行代码后，内存中的状态如下图所示：

```
graph LR
    subgraph 栈 Stack main函数的空间
        list[指针变量: list]
    end

    subgraph 堆 Heap 动态分配的内存
        HeadNode[链表头结点]
    end

    list --> |存储着地址| HeadNode

    subgraph HeadNode [头结点结构]
        H_data[data: 0]
        H_next[next: NULL]
    end
```

- `list`是 `main`函数里的一个局部指针变量，存放在栈上。
    
- `initList()`函数在堆上创建了一个真正的节点。
    
- `list`的值就是这个节点在堆上的内存地址。​**​通过这把“钥匙”，`main`函数才能找到并使用那个链表头。​**​
    

​**​图片里那句“你得先知道这玩意它怎么能造出来吗”的深意就在于此：​**​ 理解了 `initList()`是如何“造出”链表头的，你才能真正明白 `main`函数里这行代码不是在变魔术，而是在获取一个已经造好的、可用的工具。这是你后续进行插入、删除、遍历等所有链表操作的基础。

**单链表-头插法**

next也是null型，相当于null里面还有一个null就是指向下一个节点，形成铁链
![](media/Pasted%20image%2020251101151632.png)
![](media/Pasted%20image%2020251101152946.png)```

```c
#include <stdio.h> // 标准输入输出 #include <stdlib.h> // 动态内存分配

typedef int ElemType;

typedef struct node{
	ElemType data;
	struct node *next;
	//- `struct node`：指向同类型结构体的指针
    
    //`*next`：指针变量名，指向下一个节点
}Node;

//初化链表
Node* initList()
//- `Node*`：返回值类型，指向Node结构的指针  
//- `initList`：函数名
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//头插法
int insertHead(Node* L, ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

int main(int argc, char const *argv[])
{
	Node *list = initList();
	insertHead(list, 10);
	insertHead(list, 20);
	return 0;
}
```

**单链表-尾插法**
先要获取尾节点的地址才能使用尾插法

为什么头插法更简单？

1. **直接访问**：头节点始终在链表的开头，我们一开始就知道它的地址
    
2. **不需要遍历**：插入操作只涉及头节点和第一个实际节点，不需要找到链表末尾
    
3. **操作固定**：总是在同一个位置（头部）插入

```c
Node* insertTail(Node *tail,ElemType e)
{
    Node *p=(Node*)malloc(sizeof(Node));
    p->data=e;
    tail->next=p;
    p->next=NULL;
    return p;
}
```
图片表示
![](media/Pasted%20image%2020251101180308.png)
```c
#include <stdio.h>;
#include <stdlib.h>;

typedef int ElemType;

typedef struct node{
	ElemType data;
	struct node *next;
}Node;

//初化链表
Node* initList()
{
	Node *head = (Node*)malloc(sizeof(Node));
	head->data = 0;
	head->next = NULL;
	return head;
}

//头插法
int insertHead(Node* L, ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	p->next = L->next;
	L->next = p;
	return 1;
}

//遍历
void listNode(Node* L)
{
	Node *p = L->next;
	while(p != NULL)
	{
		printf("%d　", p->data);
		p = p->next;
	}
	printf("\n");
}

//获取尾部结点
Node*  get_tail(Node  *L)
{
	Node *p = L;
	while(p->next != NULL)
	{
		p = p->next;
	}
	return p;
}

//尾插法
Node* insertTail(Node *tail, ElemType e)
{
	Node *p = (Node*)malloc(sizeof(Node));
	p->data = e;
	tail->next = p;
	p->next = NULL;
	return p;
}

int main(int argc, char const *argv[])
{
	Node *list = initList();
	Node *tail = get_tail(list);
	tail  = insertTail(tail, 10);
	tail  = insertTail(tail, 20);
	tail  = insertTail(tail, 30);
	listNode(list);
	return 0;
}
```

**单链表-在指定位置插入数据**
![](media/Pasted%20image%2020251101181130.png)
先找到70的位置，然后让新的节点指向70所指向的位置，最后将70指向新的节点
```c
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;

typedef struct node{
    ElemType data;
    struct node *next;
}Node;

//初始化链表
Node* initList()
{
    Node *head = (Node*)malloc(sizeof(Node));
    head->data = 0;
    head->next = NULL;
    return head;
}

//头插法
int insertHead(Node* L, ElemType e)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = e;
    p->next = L->next;
    L->next = p;
    return 1;
}

//遍历
void listNode(Node* L)
{
    Node *p = L->next;
    while(p != NULL)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

//获取尾部结点
Node* get_tail(Node *L)
{
    Node *p = L;
    while(p->next != NULL)
    {
        p = p->next;
    }
    return p;
}

//尾插法
Node* insertTail(Node *tail, ElemType e)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = e;
    tail->next = p;
    p->next = NULL;
    return p;
}

//指定位置插入
int insertNode(Node *L, int pos, ElemType e)
{
    //用来保存插入位置的前驱节点
    Node *p = L;
    int i = 0;
    
    //遍历链表找到插入位置的前驱节点
    while(i < pos-1)
    {
        p = p->next;
        i++;
        if (p == NULL)
        {
            return 0;
        }
    }
    
    //要插入的新节点
    Node *q = (Node*)malloc(sizeof(Node));
    q->data = e;
    q->next = p->next;
    p->next = q;
    return 1;
}

int main(int argc, char const *argv[])
{
    Node *list = initList();
    Node *tail = get_tail(list);
    tail = insertTail(tail, 10);
    tail = insertTail(tail, 20);
    tail = insertTail(tail, 30);
    listNode(list);
    insertNode(list, 2, 15);
    listNode(list);
    return 0;
}
```


 **代码分节解释**

第一节：基础设置

```
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;

typedef struct node{
    ElemType data;
    struct node *next;
}Node;
```

**作用**：准备工具和定义数据结构

- 包含必要的头文件
    
- 定义链表元素类型为整数
    
- 创建节点结构，包含数据域和指向下一个节点的指针
    

第二节：链表初始化

```
Node* initList()
{
    Node *head = (Node*)malloc(sizeof(Node));
    head->data = 0;
    head->next = NULL;
    return head;
}
```

**作用**：创建一个空的链表

- 分配头节点内存
    
- 初始化头节点数据为0（可记录链表长度）
    
- 设置next指针为NULL（空链表）
    
- 返回头节点指针
    

第三节：头插法

```
int insertHead(Node* L, ElemType e)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = e;
    p->next = L->next;
    L->next = p;
    return 1;
}
```

**作用**：在链表开头插入新元素

- 创建新节点并赋值
    
- 将新节点插入到头节点之后
    
- 返回成功标志
    

第四节：遍历显示

```
void listNode(Node* L)
{
    Node *p = L->next;
    while(p != NULL)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}
```

**作用**：显示链表中所有元素

- 从第一个实际节点开始遍历
    
- 逐个打印节点数据
    
- 打印换行符
    

第五节：获取尾节点

```
Node* get_tail(Node *L)
{
    Node *p = L;
    while(p->next != NULL)
    {
        p = p->next;
    }
    return p;
}
```

**作用**：找到链表的最后一个节点

- 从头节点开始遍历
    
- 一直找到next为NULL的节点（尾节点）
    
- 返回尾节点指针
    

第六节：尾插法

```
Node* insertTail(Node *tail, ElemType e)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = e;
    tail->next = p;
    p->next = NULL;
    return p;
}
```

**作用**：在链表末尾插入新元素

- 创建新节点并赋值
    
- 将新节点接到尾节点后面
    
- 设置新节点的next为NULL
    
- 返回新的尾节点指针
    

第七节：指定位置插入

```
int insertNode(Node *L, int pos, ElemType e)
{
    Node *p = L;
    int i = 0;
    
    while(i < pos-1)
    {
        p = p->next;
        i++;
        if (p == NULL) return 0;
    }
    
    Node *q = (Node*)malloc(sizeof(Node));
    q->data = e;
    q->next = p->next;
    p->next = q;
    return 1;
}
```

**作用**：在指定位置插入新元素

- 找到要插入位置的前一个节点
    
- 创建新节点并插入到指定位置
    
- 处理越界情况（位置无效返回0）
    

第八节：主程序

```
int main(int argc, char const *argv[])
{
    Node *list = initList();          // 创建空链表
    Node *tail = get_tail(list);      // 获取尾节点
    tail = insertTail(tail, 10);      // 尾插10
    tail = insertTail(tail, 20);      // 尾插20
    tail = insertTail(tail, 30);      // 尾插30
    listNode(list);                   // 显示：10 20 30
    insertNode(list, 2, 15);          // 在第2位置插入15
    listNode(list);                   // 显示：10 15 20 30
    return 0;
}
```

**作用**：演示链表操作

- 创建链表并插入三个元素
    
- 显示链表内容
    
- 在指定位置插入新元素
    
- 再次显示链表内容验证插入结果
    

 程序执行流程总结

1. 创建空链表
    
2. 用尾插法插入10,20,30 → 链表：10→20→30→NULL
    
3. 显示链表：10 20 30
    
4. 在第2个位置插入15 → 链表：10→15→20→30→NULL
    
5. 显示链表：10 15 20 30
    

每个函数都有明确的单一职责，共同构成了完整的链表操作功能。

**单链表-删除节点**
![](media/Pasted%20image%2020251101182742.png)
```c
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;

typedef struct node{
    ElemType data;
    struct node *next;
}Node;

//初始化链表
Node* initList()
{
    Node *head = (Node*)malloc(sizeof(Node));
    head->data = 0;
    head->next = NULL;
    return head;
}

//头插法
int insertHead(Node* L, ElemType e)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = e;
    p->next = L->next;
    L->next = p;
    return 1;
}

//遍历
void listNode(Node* L)
{
    Node *p = L->next;
    while(p != NULL)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

//获取尾部结点
Node* get_tail(Node *L)
{
    Node *p = L;
    while(p->next != NULL)
    {
        p = p->next;
    }
    return p;
}

//尾插法
Node* insertTail(Node *tail, ElemType e)
{
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = e;
    tail->next = p;
    p->next = NULL;
    return p;
}

//指定位置插入
int insertNode(Node *L, int pos, ElemType e)
{
    Node *p = L;
    int i = 0;
    while(i < pos-1)
    {
        p = p->next;
        i++;
        if (p == NULL)
        {
            return 0;
        }
    }
    
    Node *q = (Node*)malloc(sizeof(Node));
    q->data = e;
    q->next = p->next;
    p->next = q;
    return 1;
}

//删除节点
int deleteNode(Node *L, int pos)
{
    //要删除节点的前驱
    Node *p = L;
    int i = 0;
    
    //遍历链表，找到要删除节点的前驱
    while(i < pos-1)
    {
        p = p->next;
        i++;
        if (p == NULL)
        {
            return 0;
        }
    }

    if(p->next == NULL)
    {
        printf("要删除的位置错误\n");
        return 0;
    }
    
    //q指向要删除的节点
    Node *q = p->next;
    //让要删除节点的前驱指向要删除节点的后继
    p->next = q->next;
    //释放要删除节点的内存空间
    free(q);
    return 1;
}

int main(int argc, char const *argv[])
{
    Node *list = initList();
    Node *tail = get_tail(list);
    tail = insertTail(tail, 10);
    tail = insertTail(tail, 20);
    tail = insertTail(tail, 30);
    listNode(list);  // 输出：10 20 30
    
    insertNode(list, 2, 15);
    listNode(list);  // 输出：10 15 20 30
    
    deleteNode(list, 2);
    listNode(list);  // 输出：10 20 30
    
    return 0;
}
```
```
```

**指针重新指向的详细解释**

让我用一个具体的例子来详细解释"让前驱节点直接指向要删除节点的下一个节点"这个过程。

初始链表状态

```
头节点 → 节点A(10) → 节点B(20) → 节点C(30) → NULL
```

假设我们要删除节点B（值为20）

删除前的指针关系

```
头节点 → 节点A(10) → 节点B(20) → 节点C(30) → NULL
          ↑          ↑
         p指向      q指向 (p->next)
```

删除操作的三步走

步骤1：记录要删除的节点

```
Node *q = p->next;  // q指向节点B
```

现在的关系：

```
头节点 → 节点A(10) → 节点B(20) → 节点C(30) → NULL
          ↑          ↑
         p指向      q指向
```

步骤2：关键操作 - 指针重新指向

```
p->next = q->next;  // 让节点A指向节点C
```

**这个操作的具体含义：**

- `p->next`是节点A的next指针
    
- `q->next`是节点B的next指针（指向节点C）
    
- 这个赋值操作相当于：**把节点A的next指针，从指向节点B改为指向节点C**
    

执行后的结果：

```
头节点 → 节点A(10) → 节点C(30) → NULL
                    ↗
节点B(20) → 节点C(30)  (但节点B已经被"绕过")
          ↑
         q指向 (但q已经不在链表中)
```

步骤3：释放内存

```
free(q);  // 释放节点B的内存
```

最终结果：

```
头节点 → 节点A(10) → 节点C(30) → NULL
```

更形象的比喻

把链表想象成一列火车，每个节点是一节车厢，指针是连接车厢的挂钩：

**删除前：**

```
火车头 → 车厢A → 车厢B → 车厢C
```

**删除操作：**

1. 先找到车厢B的前一节车厢A
    
2. 把车厢A的挂钩从车厢B上摘下来
    
3. 把车厢A的挂钩挂到车厢C上
    
4. 把车厢B拖走销毁
    

**删除后：**

```
火车头 → 车厢A → 车厢C
```

关键理解点

1. **`p->next = q->next`不是移动数据，而是修改指针关系**
    
2. **节点B本身没有被修改，只是不再被链表引用**
    
3. **链表的结构通过改变指针指向来调整**
    
4. **内存释放是最后一步，确保节点不再被使用**
    

代码执行过程可视化

```
// 删除前：p指向节点A，q指向节点B
// 链表：A→B→C

p->next = q->next;
// 执行后：节点A的next指针现在指向节点C
// 链表：A→C，但B→C的关系仍然存在（只是B不再被链表引用）

free(q);
// 执行后：节点B的内存被回收
// 链表：A→C
```

这就是链表删除的核心机制：**通过修改指针的指向关系来调整链表结构，而不是移动数据本身**。

**单链表-释放链表**
![](media/Pasted%20image%2020251101184724.png)
```c
//释放链表
void freeList(Node *L)
{
    Node *p = L;  // 从头节点开始释放
    Node *q;
    
    while(p != NULL)
    {
        q = p->next;  // 保存下一个节点的地址
        free(p);      // 释放当前节点
        p = q;        // 移动到下一个节点
    }
    printf("链表内存已释放\n");
}
```
**释放过程详解**

初始链表状态：

`头节点 → 节点10 → 节点20 → 节点30 → NULL`

释放过程步骤：

**第1次循环：**

- `p`指向头节点
    
- `q = p->next`→ `q`指向节点10
    
- `free(p)`→ 释放头节点的内存
    
- `p = q`→ `p`指向节点10
    

**第2次循环：**

- `p`指向节点10
    
- `q = p->next`→ `q`指向节点20
    
- `free(p)`→ 释放节点10的内存
    
- `p = q`→ `p`指向节点20
    

**第3次循环：**

- `p`指向节点20
    
- `q = p->next`→ `q`指向节点30
    
- `free(p)`→ 释放节点20的内存
    
- `p = q`→ `p`指向节点30
    

**第4次循环：**

- `p`指向节点30
    
- `q = p->next`→ `q`指向NULL
    
- `free(p)`→ 释放节点30的内存
    
- `p = q`→ `p`指向NULL
    

**循环结束**，所有节点内存都已释放。

为什么需要这样释放？

1. **顺序很重要**：必须先保存下一个节点的地址，再释放当前节点
    
2. **包含头节点**：头节点也是动态分配的，需要一起释放
    
3. **避免内存泄漏**：确保所有动态分配的内存都被正确释放
    

重要注意事项

在调用`freeList(list)`后，`list`指针变成了一个**悬空指针**（dangling pointer），它仍然指向原来的内存地址，但该内存已经被释放。继续使用这个指针会导致未定义行为。

**正确做法**：

`freeList(list); list = NULL;  // 将指针设置为NULL，避免悬空指针`

程序输出结果

`10 20 30 10 15 20 30 10 20 30 链表长度: 3 链表内存已释放`

这个修正后的程序包含了完整的链表操作功能，并正确处理了内存释放，避免了内存泄漏问题。