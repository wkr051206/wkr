好的，这是对《单链表的概念及创建》章节知识点的详细总结，包括所有核心概念和代码实现。

---

### **《单链表的概念及创建》章节知识点总结**

本章节核心是讲解线性表的第二种物理存储结构——**单链表**。重点在于理解其**链式存储**的本质、**结点**的构成，以及两种创建链表的方法：**头插法**和**尾插法**。

#### **一、单链表的核心概念**

1. **定义**：
    
    - 单链表是一种**链式存储**结构，用一组**地址任意**（可以不连续）的存储单元来存放线性表中的数据元素。
        
    
2. **核心思想**：
    
    - 逻辑上相邻的数据元素，在物理存储位置上**不要求相邻**。
        
    - 数据元素之间的逻辑关系通过**指针**来链接。
        
    
3. **结点（Node）**：
    
    - 链表中的基本存储单元，由两部分构成：
        
        - **数据域（Data）**：存放数据元素的值。
            
        - **指针域（Next）**：存放指向**下一个结点**的地址（指针）。
            
        
    
4. **头指针（Head Pointer）**：
    
    - 指向链表第一个结点的指针。它是链表的入口，没有头指针就无法访问整个链表。
        
    - 通常使用一个名为 `Head`或 `L`的指针变量来担任。
        
    
5. **头结点（Head Node）**：
    
    - 在链表的第一个数据结点之前附加的一个结点。
        
    - **数据域**：可以不存储任何信息，也可以存放表长等附加信息。
        
    - **指针域**：指向第一个数据结点。
        
    - **优点**：简化操作。无论链表是否为空，头指针始终指向头结点，使得对第一个数据结点的插入、删除操作与对其他结点的操作统一。
        
    

#### **二、单链表的存储结构（C语言描述）**

```
// 定义结点类型
typedef struct LNode {
    ElemType data;      // 数据域
    struct LNode *next; // 指针域，指向下一个结点
} LNode, *LinkList;     // 两种等价的类型名

// LNode* 和 LinkList 是等价的，都表示指向结点的指针。
// 但通常用 LinkList 来定义头指针，强调其代表整个链表。
// 例如：
LinkList Head; // Head 是单链表的头指针
```

#### **三、单链表的创建方法**

创建链表的核心是**动态分配内存**（`malloc`）来生成新结点，并通过修改指针将它们链接起来。

##### **方法一：头插法（逆序创建）**

- **特点**：新结点总是插入在链表的**头部**（头结点之后）。最终生成的链表中，数据元素的顺序与输入顺序**相反**。
    
- **算法步骤**：
    
    1. 初始化一个只有头结点的空链表。
        
    2. 循环 `n`次，每次：
        
        - `malloc`动态分配一个新结点 `p`。
            
        - 给新结点 `p`的数据域赋值。
            
        - 将新结点 `p`的 `next`指针指向原第一个数据结点（即 `Head->next`）。
            
        - 将头结点的 `next`指针指向新结点 `p`。
            
        
    
- **代码实现**：
    
    ```
    // 头插法创建单链表
    void CreateList_Head(LinkList &Head, int n) {
        // 1. 创建头结点
        Head = (LinkList)malloc(sizeof(LNode));
        Head->next = NULL; // 建立一个带头结点的空链表
    
        // 2. 循环创建并插入n个结点
        for (int i = 0; i < n; i++) {
            LNode *p = (LinkList)malloc(sizeof(LNode)); // 生成新结点p
            scanf("%d", &(p->data)); // 输入元素值，假设为int型
    
            // 核心操作：将新结点p插入到头结点之后
            p->next = Head->next; // 步骤①：p的next指向原第一个结点
            Head->next = p;       // 步骤②：头结点的next指向新结点p
        }
    }
    ```
    
- **图示**：`Head -> [新结点3] -> [新结点2] -> [新结点1] -> NULL`（输入顺序为1, 2, 3）
    

##### **方法二：尾插法（正序创建）**

- **特点**：新结点总是插入在链表的**尾部**。最终生成的链表中，数据元素的顺序与输入顺序**完全相同**。
    
- **算法步骤**：
    
    1. 初始化一个只有头结点的空链表。
        
    2. 设置一个**尾指针 `r`**，初始时指向头结点。
        
    3. 循环 `n`次，每次：
        
        - `malloc`动态分配一个新结点 `p`。
            
        - 给新结点 `p`的数据域赋值，并将其 `next`指针置为 `NULL`。
            
        - 将尾指针 `r`的 `next`指针指向新结点 `p`。
            
        - 将尾指针 `r`指向新结点 `p`（`r`后移，保持指向新的表尾）。
            
        
    
- **代码实现**：
    
    ```
    // 尾插法创建单链表
    void CreateList_Tail(LinkList &Head, int n) {
        // 1. 创建头结点
        Head = (LinkList)malloc(sizeof(LNode));
        Head->next = NULL;
        LNode *r = Head; // 尾指针r初始指向头结点
    
        // 2. 循环创建并插入n个结点
        for (int i = 0; i < n; i++) {
            LNode *p = (LinkList)malloc(sizeof(LNode)); // 生成新结点p
            scanf("%d", &(p->data)); // 输入元素值
            p->next = NULL; // 新结点将是表尾，其next置为NULL
    
            // 核心操作：将新结点p插入到尾结点r之后
            r->next = p; // 步骤①：原尾结点的next指向新结点p
            r = p;       // 步骤②：尾指针r指向新的表尾结点p
        }
    }
    ```
    
- **图示**：`Head -> [结点1] -> [结点2] -> [结点3] -> NULL`（输入顺序为1, 2, 3）
    

#### **四、课堂练习解析**

1. **题目**：关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（B）。
    
    - **I. 顺序存储优于链式存储**：错误。各有优缺点，适用场景不同。
        
    - **II. 链式能更方便地表示各种逻辑结构**：正确。链表可以灵活地表示树、图等复杂结构。
        
    - **III. 频繁插入删除时顺序存储更优**：错误。顺序存储插入删除需要移动大量元素（O(n)），而链式存储只需修改指针（O(1)），链式更优。
        
    - **IV. 两者都可顺序存取**：正确。顺序表是随机存取，链表是顺序存取，但“顺序存取”是一种方式，链表符合。
        
    - **答案**：B. II、IV
        
    
2. **题目**：设线性表中有n个元素，下列（D）操作在单链表上实现比在顺序表上实现效率更高。
    
    - **A. 查找并输出第i个元素**：顺序表O(1)，链表O(n)，顺序表更优。
        
    - **B. 顺序输出前i个元素**：两者都是O(i)，效率相当。
        
    - **C. 在表尾插入新元素**：两者都是O(1)（顺序表预分配空间充足时），效率相当。
        
    - **D. 查找并删除第i个元素**：顺序表需要查找O(1)+移动元素O(n)，链表需要查找O(n)+修改指针O(1)。虽然都是O(n)，但链表“修改指针”的操作通常比顺序表“移动大量元素”开销小，尤其在数据量大时优势更明显。**因此D是更合适的答案。**
        
    

#### **五、内容小结**

1. **存储方式**：链式存储，结点地址**不要求连续**。
    
2. **逻辑关系**：通过**指针**表示元素间的逻辑关系。
    
3. **与顺序表的对比**：
    
    - **优点**：
        
        - 插入、删除操作效率高，只需修改指针，无需移动元素。
            
        - 存储空间动态分配，无需预先确定容量，不会造成空间浪费。
            
        
    - **缺点**：
        
        - 存取效率低，必须从头开始顺序查找（顺序存取）。
            
        - 每个结点除了数据域，还有指针域，存储密度较低。
            
        
    

通过本章学习，应能深刻理解单链表的链式存储思想，熟练掌握头插法和尾插法创建链表的原理、步骤和代码实现，并能清晰比较顺序表和链表的优缺点。