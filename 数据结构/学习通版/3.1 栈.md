##### **一、核心概念**

1. **定义**：栈是限定**仅在表尾（栈顶）**​ 进行插入（**入栈/Push**）和删除（**出栈/Pop**）操作的线性表。
    
2. **特点**：**后进先出（LIFO, Last In First Out）**。最后入栈的元素最先出栈。
    
3. **术语**：
    
    - **栈顶**：允许插入和删除的一端。
        
    - **栈底**：不允许进行操作的一端。
        
    - **空栈**：不含任何数据元素的栈。
        
    

![](https://hunyuan-plugin-private-1258344706.cos.ap-nanjing.myqcloud.com/pdf_youtu/img/be6fdce3e81efe628a6ef54e1cd05ba8-image.png?q-sign-algorithm=sha1&q-ak=AKID372nLgqocp7HZjfQzNcyGOMTN3Xp6FEA&q-sign-time=1764051168%3B2079411168&q-key-time=1764051168%3B2079411168&q-header-list=host&q-url-param-list=&q-signature=a8a26b9117b2953fb782248460c229d26e7bd545)

##### **二、顺序栈的实现**

栈的顺序存储结构利用一组地址连续的存储单元（数组）存放数据元素，并附设一个指针`top`指示栈顶元素的位置。

- **存储结构定义**：
    
    ```
    #define MAX 100
    int stack[MAX];
    int top = 0; // 通常约定top指向栈顶元素的下一个位置
    ```
    
- **基本操作**：
    
    1. **入栈操作（Push）**
        
        ```
        void Push(int x) {
            if (top >= MAX) {
                printf("Stack Overflow!\n");
            } else {
                stack[top] = x;
                top++;
            }
        }
        ```
        
    2. **出栈操作（Pop）**
        
        ```
        int Pop() {
            if (top == 0) {
                printf("Stack Underflow!\n");
                return NULL;
            } else {
                top--;
                return stack[top];
            }
        }
        ```
        
        - **特点**：存取定位方便，但需要预先分配固定大小的空间。
            
        
    
- **共享栈**：为了更有效地利用存储空间，可以让两个顺序栈共享一个一维数组。两个栈的栈底分别设在数组的两端，栈顶向中间延伸。
    

##### **三、链栈的实现**

栈的链式存储结构称为链栈。其优点是无需预先设定容量，多个栈共享空间也更方便。

- **存储结构定义**：
    
    ```
    typedef struct Node {
        int data;
        struct Node* link;
    } NODE;
    NODE* top = NULL; // 链栈的栈顶指针
    ```
    
- **基本操作**：
    
    1. **入栈操作（Push）**
        
        ```
        void Push(int x) {
            NODE* p = (NODE*)malloc(sizeof(NODE));
            p->data = x;
            p->link = top; // 新结点指向原栈顶
            top = p;       // 栈顶指针指向新结点
        }
        ```
        
    2. **出栈操作（Pop）**
        
        ```
        NODE* Pop() {
            NODE* p;
            if (top == NULL) return NULL;
            p = top;
            top = top->link; // 栈顶指针下移
            return p;       // 返回被删除的结点
        }
        ```
