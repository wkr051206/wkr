好的，这是对《单链表的相关操作》章节知识点的详细总结，包括所有核心算法和代码实现。

---

### **《单链表的相关操作》章节知识点总结**

本章节是单链表学习的核心，详细讲解了单链表的三种基本操作：**查找、插入和删除**。掌握这些操作的原理和代码实现是灵活运用链表的基础。

#### **一、单链表的查找操作**

1. **操作目的**：获取单链表中**第 i 个**数据元素的值。
    
2. **核心思想**：由于单链表是**顺序存取**结构，无法像数组一样通过下标直接访问。必须从**头结点**开始，沿着 `next`指针逐个节点向后遍历，直到找到第 `i`个节点。
    
3. **算法步骤**：
    
    1. 初始化：指针 `p`指向第一个数据结点 (`Head->next`)，计数器 `k`初始为 1。
        
    2. 循环：若 `p`不为空且 `k < i`，则让 `p`指向下一个结点，`k`加 1。
        
    3. 判断：循环结束后，如果 `p`为空或 `k > i`，说明第 `i`个元素不存在。
        
    4. 取值：否则，`p`正好指向第 `i`个结点，取出其数据域 `p->data`。
        
    
4. **代码实现**：
    
    ```
    // 获取单链表第i个元素的值，通过e返回
    Status GetElem(LinkList Head, int i, ElemType &e) {
        LNode *p = Head->next; // p指向第一个数据结点
        int k = 1; // 计数器
    
        // 向后遍历，直到p指向第i个结点或p为空
        while (p != NULL && k < i) {
            p = p->next;
            k++;
        }
    
        // 检查i是否合法（i值太大或太小）
        if (p == NULL || k > i) {
            return ERROR; // 第i个元素不存在
        }
    
        e = p->data; // 取第i个元素的值
        return OK;
    }
    ```
    
5. **时间复杂度**：**O(n)**。最坏情况（查找最后一个元素）需要遍历整个链表。
    

#### **二、单链表的插入操作**

1. **操作目的**：在单链表的**第 i 个**位置之前插入一个新的数据元素 `e`。
    
2. **核心思想**：找到第 **i-1**​ 个结点（即要插入位置的前驱结点），然后修改相关指针，将新结点插入。
    
3. **关键步骤**（“后连再前断”）：
    
    1. 新结点 `s`的 `next`指针指向第 `i`个结点 (`s->next = p->next`)。
        
    2. 第 `i-1`个结点 `p`的 `next`指针指向新结点 `s`(`p->next = s`)。
        
        - **顺序至关重要**：如果先执行步骤2，就会丢失与第 `i`个结点的链接。
            
        
    
4. **算法步骤**：
    
    1. 调用查找算法，找到第 `i-1`个结点，用指针 `p`指向它。
        
    2. 检查插入位置 `i`是否合法。
        
    3. 为新元素 `e`分配新结点 `s`，并赋值 (`s->data = e`)。
        
    4. 执行核心的指针修改操作。
        
    
5. **代码实现**：
    
    ```
    // 在带头结点的单链表L的第i个位置之前插入元素e
    Status ListInsert(LinkList &L, int i, ElemType e) {
        LNode *p = L; // p指向头结点
        int k = 0;
    
        // 寻找第i-1个结点，p指向该结点
        while (p != NULL && k < i - 1) {
            p = p->next;
            k++;
        }
    
        // i大于表长+1 或 i小于1，位置不合法
        if (p == NULL || k > i - 1) {
            return ERROR;
        }
    
        // 创建新结点s
        LNode *s = (LNode *)malloc(sizeof(LNode));
        if (s == NULL) exit(OVERFLOW); // 内存分配失败
        s->data = e;
    
        // 核心操作：插入新结点s
        s->next = p->next; // 步骤1：s的后继指向原第i个结点
        p->next = s;       // 步骤2：p的后继指向新结点s
    
        return OK;
    }
    ```
    
6. **时间复杂度**：**O(n)**。时间主要消耗在查找第 `i-1`个结点上。实际的插入操作（修改指针）是 **O(1)**。
    

#### **三、单链表的删除操作**

1. **操作目的**：删除单链表中**第 i 个**数据元素，并通过参数 `e`返回其值。
    
2. **核心思想**：找到第 **i-1**​ 个结点（即被删除结点的前驱结点），然后修改其 `next`指针，绕过第 `i`个结点，最后释放被删除结点的内存。
    
3. **算法步骤**：
    
    1. 调用查找算法，找到第 `i-1`个结点，用指针 `p`指向它。
        
    2. 检查删除位置 `i`是否合法（即 `p->next`不能为空）。
        
    3. 用指针 `q`临时保存待删除结点 (`q = p->next`)。
        
    4. 修改指针，将结点 `p`的 `next`指向 `q`的后继结点 (`p->next = q->next`)。
        
    5. 将 `q`结点的数据赋给 `e`，然后释放 `q`所占用的内存。
        
    
4. **代码实现**：
    
    ```
    // 删除带头结点的单链表L的第i个元素，并用e返回其值
    Status ListDelete(LinkList &L, int i, ElemType &e) {
        LNode *p = L; // p指向头结点
        int k = 0;
    
        // 寻找第i-1个结点，p指向该结点
        while (p->next != NULL && k < i - 1) {
            p = p->next;
            k++;
        }
    
        // 检查i是否合法（i大于表长或i小于1）
        if (p->next == NULL || k > i - 1) {
            return ERROR;
        }
    
        // 执行删除操作
        LNode *q = p->next; // q指向待删除的第i个结点
        p->next = q->next;  // 绕过第i个结点，将i-1与i+1连接起来
        e = q->data;        // 保存被删除结点的值
        free(q);            // 释放被删除结点的内存
    
        return OK;
    }
    ```
    
5. **时间复杂度**：**O(n)**。时间主要消耗在查找第 `i-1`个结点上。实际的删除操作（修改指针和释放内存）是 **O(1)**。
    

#### **四、综合应用实例：交换链表前后部分**

1. **问题**：将单链表 `(a1, a2, ..., am, b1, b2, ..., bn)`变为 `(b1, b2, ..., bn, a1, a2, ..., am)`。
    
2. **算法思想（三指针法）**：
    
    - **目标**：将 `b1...bn`这一段移动到 `a1...am`之前。
        
    - **步骤**：
        
        1. **找 `am`结点**：指针 `ta`从头遍历，停在第 `m`个结点 `am`上。
            
        2. **找 `b1`和 `bn`结点**：`hb`(head of b) 指向 `am`的后继，即 `b1`。指针 `tb`从 `hb`出发，遍历到最后一个结点 `bn`。
            
        3. **执行交换**：
            
            - 将 `am`的 `next`指针置为 `NULL`（断开原链表）。
                
            - 将 `bn`的 `next`指针指向原链表的第一个数据结点 `a1`(`L->next`)。
                
            - 将头结点 `L`的 `next`指针指向 `b1`(`hb`)。
                
            
        
    
3. **代码实现**：
    
    ```
    void Exchange(LinkList &L, int m) {
        LNode *ta = L; // ta最终指向am结点
        int i = 0;
        // 1. 寻找第m个结点am，ta指向它
        while (ta != NULL && i < m) {
            ta = ta->next;
            i++;
        }
    
        // 2. 如果m小于表长，则进行交换
        if (ta != NULL && ta->next != NULL) {
            LNode *hb = ta->next; // hb指向b1
            LNode *tb = hb;       // tb用于寻找bn
    
            // 3. 遍历找到bn结点
            while (tb->next != NULL) {
                tb = tb->next;
            }
    
            // 4. 核心操作：交换部分
            ta->next = NULL;   // 断开a序列和b序列
            tb->next = L->next; // 将b序列的尾部接上a序列的头部
            L->next = hb;      // 将头结点指向b序列的头部
        }
    }
    ```
    
4. **时间复杂度**：**O(n)**。需要遍历链表找到 `am`和 `bn`。
    

#### **五、内容小结与要点回顾**

1. **存取方式**：单链表是**顺序存取**结构，查找第 `i`个元素必须从头遍历，时间复杂度为 **O(n)**。
    
2. **操作核心**：插入和删除操作的核心是**修改指针**。无论插入或删除，都需要**先找到前驱结点（第 i-1 个结点）**。
    
3. **指针修改顺序**：插入时，先连新结点与后继，再连前驱与新结点；删除时，先备份再绕开，最后释放。顺序至关重要，否则会丢失节点。
    
4. **与顺序表的对比**：
    
    - **优点**：插入、删除无需移动元素，只需修改指针，效率高（O(1)的指针操作，但查找前驱是O(n)）；存储空间动态分配。
        
    - **缺点**：失去了顺序表随机存取（O(1)）的优点。