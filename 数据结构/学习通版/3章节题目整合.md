![](media/Pasted%20image%2020251122232749.png)
1. **在尾元素之后插入一个元素**：这需要快速定位到尾元素。
    
2. **删除第一个元素**：这需要快速定位到第一个元素。

  下面分析每个选项的效率：

- **A、单链表**：
    
    - 插入操作：需要遍历整个链表才能找到尾元素，时间复杂度为 O(n)。
        
    - 删除操作：删除第一个元素只需修改头指针，时间复杂度为 O(1)。
        
    - 整体效率低，因为插入操作耗时。
        
    
- **B、仅有头节点指针的循环单链表**：
    
    - 插入操作：要找到尾元素（即头节点的前驱），需要遍历整个链表，时间复杂度为 O(n)。
        
    - 删除操作：删除第一个元素（头节点的下一个）是 O(1)。
        
    - 整体效率仍低，因为插入操作耗时。
        
    
- **C、双链表**：
    
    - 插入操作：如果维护了尾指针，插入尾后可达 O(1)，但选项未指定尾指针，通常需要遍历找到尾元素，时间复杂度为 O(n)。
        
    - 删除操作：删除第一个元素是 O(1)。
        
    - 但双链表的空间开销较大（每个节点有两个指针），且在没有尾指针的情况下，插入效率不高。
        
    
- **D、仅有尾指针的循环单链表**：
    
    - 插入操作：尾指针直接指向尾元素，在尾元素之后插入新元素只需修改相关指针，时间复杂度为 O(1)。
        
    - 删除操作：第一个元素是尾指针的下一个节点（即 `tail->next`），直接删除并调整指针，时间复杂度为 O(1)。
        
    - 两个操作都是 O(1)，最节省时间。
        
    

**总结**：仅有尾指针的循环单链表能同时高效支持这两个操作，因为它利用循环特性，通过尾指针直接访问尾元素和第一个元素，无需遍历。因此，选项 D 是最优选择。
### 核心概念：什么是双链表？

- **单链表**的节点结构：`数据域 | 下一个节点的地址（next指针）`
    
    - 它只存储了指向**后继节点**的指针。所以只能从当前节点向后访问，**无法直接知道前一个节点是谁**。
        
    
- **双链表**的节点结构：`上一个节点的地址（prev指针） | 数据域 | 下一个节点的地址（next指针）`
    
    - 它**额外存储了一个指向前驱节点**的指针（通常叫 `prior`或 `prev`）。
        
    - 这样，每个节点都同时知道自己的“左邻”和“右舍”。

![](media/Pasted%20image%2020251122233422.png)
正确答案是 **B. 对于两个链表来说，删除尾节点的操作，其时间复杂度都是O(n)**。

### 解题思路：

这道题考察的是**不带表头结点**的循环/非循环单链表的基本操作效率。关键点在于“**不带表头结点**”和“**单链表**”这两个前提条件。

下面我们逐一分析每个选项：

**Ⓐ 对于两个链表来说，删除首节点的操作，其时间复杂度都是O(1)**

- **这个说法是错误的。**
    
- **非循环链表 (h2)**：删除首节点需要将头指针 `h2`指向第二个节点。这个操作本身是 **O(1)**。
    
- **循环链表 (h1)**：删除首节点后，需要将**尾节点的指针**（原来指向被删除的首节点）指向新的首节点（即原第二个节点）。但是，在**不带表头结点**且**只知道头指针h1**的情况下，要找到尾节点来修改其指针，必须从 `h1`开始遍历整个链表，直到某个节点的 `next`指向 `h1`，这个节点才是尾节点。这个遍历操作的时间复杂度是 **O(n)**。
    
- 因此，对于循环链表h1，删除首节点的时间复杂度是 **O(n)**，而不是O(1)。
    

**Ⓑ 对于两个链表来说，删除尾节点的操作，其时间复杂度都是O(n)**

- **这个说法是正确的。**
    
- **非循环链表 (h2)**：要删除尾节点，必须先找到尾节点的**前驱节点**（因为需要修改前驱节点的 `next`指针）。在单链表中，寻找一个节点的前驱节点需要从头开始遍历，直到某个节点的 `next`指向尾节点。这个过程的时间复杂度是 **O(n)**。
    
- **循环链表 (h1)**：同样，要删除尾节点，也需要找到尾节点的前驱节点。虽然h1是循环的，尾节点指向h1，但要找到尾节点的前驱节点，同样需要从头遍历，时间复杂度也是 **O(n)**。
    
- 所以，无论链表是否循环，在**不带表头结点**的单链表中，删除尾节点都需要 **O(n)**​ 的时间。
    

**Ⓒ 循环链表要比非循环链表占用更多的内存空间**

- **这个说法是错误的。**
    
- 两种链表的**节点结构完全相同**（都是一个数据域+一个指针域），并没有因为它是循环链表就在节点中增加额外的存储空间。循环与否只是指针的链接方式不同，并不会影响每个节点所占用的内存空间大小。因此，对于长度都为n的两个链表，它们占用的总内存空间是相同的。
    

**Ⓓ h1和h2是不同类型的变量**

- **这个说法是错误的。**
    
- 题目已明确说明“结点类型都相同”。`h1`和 `h2`都是指向这种相同结点类型的**头指针**，因此它们是**同类型**的指针变量。链表的循环与否是逻辑结构上的区别，并不改变头指针变量的数据类型。
    

### 核心知识点总结：

- **删除尾节点的效率**：在**不带表头结点**的**单链表**中（无论是否循环），删除尾节点都需要**遍历**以找到其前驱节点，时间复杂度恒为 **O(n)**。
    
- **循环链表的特性**：循环链表的尾节点指向头节点（或首节点），但这并不提供快速找到前驱节点的能力。
    
- **头指针的类型**：头指针的类型由它所指的节点类型决定。只要节点类型相同，头指针就是同类型的。
 ![](media/Pasted%20image%2020251122234240.png)
根据您提供的图片内容，正确答案是 **A、只有表头指针的不带表头节点的循环单链表**。

### 解题思路：

这道题考查的是在不同类型的单链表中删除第一个元素的时间复杂度。关键因素在于链表是否带表头节点、是否有表尾指针，以及是否为循环结构。

- **对于A选项（只有表头指针的不带表头节点的循环单链表）**：
    
    - 由于没有表头节点，表头指针直接指向第一个数据节点。要删除第一个元素，需要将表头指针指向第二个节点，但因为是循环链表，还必须更新尾节点的指针，使其指向新的第一个节点（即原第二个节点）。
        
    - 然而，只有表头指针的情况下，要找到尾节点（即指向第一个节点的节点），必须从表头开始遍历整个链表，直到找到某个节点的`next`指针指向第一个节点。这个遍历操作的时间复杂度为O(n)。
        
    - 因此，删除第一个元素的时间复杂度为O(n)。
        
    
- **对于B选项（只有表尾指针的不带表头节点的循环单链表）**：
    
    - 表尾指针直接指向尾节点，而尾节点的`next`指针指向第一个节点。删除第一个元素时，可以直接通过表尾指针访问第一个节点和第二个节点，修改指针关系即可，无需遍历链表。时间复杂度为O(1)，而不是O(n)。
        
    
- **对于C选项（只有表尾指针的带表头节点的循环单链表）**：
    
    - 带表头节点时，删除第一个数据节点（即表头节点的下一个节点）可以通过表尾指针快速访问表头节点（因为循环链表中尾节点的`next`指向表头节点），然后直接修改指针。时间复杂度为O(1)，而不是O(n)。
        
    
- **对于D选项（只有表头指针的带表头节点的循环单链表）**：
    
    - 带表头节点时，删除第一个数据节点只需修改表头节点的`next`指针，指向第二个数据节点。无需遍历链表，时间复杂度为O(1)，而不是O(n)。
        
    

综上，只有A选项满足删除第一个元素的时间复杂度为O(n)。您的答案B是错误的，因为B选项在删除第一个元素时不需要遍历链表，效率更高。
![](media/Pasted%20image%2020251122234616.png)
正确答案是 **D、4**。

### 解题思路：

这道题考查的是**双链表**的插入操作。关键在于理解双链表的每个结点都有**两个指针域**：一个指向前驱结点（`prior`），一个指向后继结点（`next`）。

当我们想要在两个结点（假设为 `p`和 `p->next`）之间插入一个新结点 `s`时，需要修改以下**四个**指针域，才能正确完成插入并维持双链表的双向关系：

1. **新结点 `s`的 `prior`指针**：需要指向它的前驱结点 `p`。
    
    `s->prior = p;`
    
2. **新结点 `s`的 `next`指针**：需要指向它的后继结点（即原 `p`的后继结点）。
    
    `s->next = p->next;`
    
3. **原后继结点（`p->next`）的 `prior`指针**：这个结点的前驱指针原来指向 `p`，现在需要改为指向新结点 `s`。
    
    `p->next->prior = s;`
    
4. **前驱结点 `p`的 `next`指针**：需要从指向原后继结点改为指向新结点 `s`。
    
    `p->next = s;`
    

**图解过程：**

插入前的关系： `p <---> (p->next)`

插入后的关系： `p <---> s <---> (p->next)`

**为什么不是2个？**

如果只修改新结点 `s`的两个指针（即步骤1和2），那么 `s`知道它的前驱和后继是谁，但链表中的 `p`和 `(p->next)`这两个结点并不知道 `s`的存在。必须通过步骤3和4，让它们也“认识” `s`，链表才能重新连接起来。

**总结：**

双链表的插入操作需要修改 **4**​ 个指针，以确保前后结点的链接都正确无误。这是双链表操作的一个核心知识点。
![](media/Pasted%20image%2020251122235709.png)
正确答案是 **B、便于随机存取**。

### 解题思路：

这道题考查的是**线性表的顺序存储结构**和**链式存储结构**的核心区别与优缺点。

**1. 核心概念区分：**

- **顺序存储结构（顺序表）**：用一段**地址连续**的存储单元依次存储数据元素，通常用数组实现。
    
- **链式存储结构（链表）**：用一组**地址任意**的存储单元存储数据元素，通过指针来表示元素之间的逻辑关系。
    

**2. 选项分析：**

- **A. 所有的操作算法实现简单**
    
    - **错误**。顺序存储结构在**插入**和**删除**操作时需要移动大量元素，算法实现并不简单，平均时间复杂度为O(n)。而链式存储的插入删除只需修改指针，算法相对更直接。
        
    
- **B. 便于随机存取**
    
    - **正确**。这是顺序存储结构最显著的优点。由于元素在内存中连续存放，只要知道基地址和每个元素的大小，就可以通过一个简单的公式 `LOC(a_i) = LOC(a_1) + (i-1)*C`直接计算出第 `i`个元素的地址，从而在 **O(1)**​ 时间内访问它。链式存储结构无法做到这一点，必须从头开始顺序查找。
        
    
- **C. 便于插入和删除**
    
    - **错误**。这恰恰是**链式存储结构**的优点。链式存储进行插入或删除时，只需修改相关节点的指针，时间复杂度为O(1)（如果已知插入/删除位置的前驱节点）。而顺序存储则需要移动平均一半的元素，效率较低。
        
    
- **D. 便于顺序存取**
    
    - **不准确/非最佳答案**。顺序存储和链式存储都支持顺序存取（即从头到尾依次访问）。但“便于顺序存取”并非顺序存储相比链式存储的独特优点。链式存储也是顺序存取的。题目问的是顺序存储相对于链式存储的优点，因此B选项“随机存取”是其最核心的优势。
        
    

### 总结对比：

|特性|顺序存储结构|链式存储结构|
|---|---|---|
|**存取方式**​|**随机存取**​ (O(1)，**核心优势**)|顺序存取 (O(n))|
|**插入/删除**​|平均需要移动大量元素 (O(n))|只需修改指针 (O(1)，**核心优势**)|
|**存储密度**​|高（只存数据）|低（还需存储指针）|
|**空间分配**​|静态预分配，不灵活|动态分配，灵活|

因此，与链式存储结构相比，线性表的顺序存储结构最主要的优点是**便于随机存取**。