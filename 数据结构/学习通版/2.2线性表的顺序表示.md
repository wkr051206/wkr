好的，这是对《线性表的顺序表示》这一章节知识点的详细总结，包括所有核心概念和代码实现部分。

---

### **《线性表的顺序表示》章节知识点总结**

本章节核心是讲解线性表的第一种物理存储结构——**顺序表**，重点在于理解其**用数组实现**的本质、**随机存取**的特性，以及**插入、删除操作需要移动大量元素**的特点。

#### **一、顺序表的定义与核心特性**

1. **定义**：
    
    - 线性表的**顺序存储**称为顺序表。
        
    - 它使用一组**地址连续**的存储单元（通常用数组实现），依次存放线性表中的数据元素。
        
    
2. **核心特性**：
    
    - **逻辑顺序与物理顺序一致**：数据元素之间的逻辑关系（前驱、后继）通过物理上的**存储位置相邻**来直接反映。即，第 `i`个元素的存储位置紧邻着第 `i-1`个和第 `i+1`个元素。
        
    - **随机存取（Random Access）**：这是顺序表最重要的特性。由于存储空间连续，我们可以通过**基地址**直接计算出任何一个元素的存储位置。
        
        - **地址计算公式**：`LOC(a_i) = LOC(a_1) + (i - 1) * C`
            
        - 其中，`LOC(a_1)`是基地址，`C`是每个元素占用的存储空间大小。
            
        - 通过这个公式，访问第 `i`个元素的时间复杂度为 **O(1)**。
            
        
    
3. **重要细节**：
    
    - 线性表的**位序（Position）**​ 从 **1**​ 开始计数。
        
    - 在C语言中，用于实现顺序表的**数组下标**从 **0**​ 开始计数。
        
    - 因此，顺序表中**位序为 i**​ 的元素，在数组中的**下标为 i-1**。
        
    

#### **二、顺序表的存储结构（C语言描述）**

顺序表在代码中通常被定义为一个结构体，它包含了管理这个动态数组所需的所有信息。

```
typedef struct {
    ElemType *elem;      // 存储空间基址，指向动态数组的首元素
    int length;          // 当前顺序表的长度（即元素个数）
    int listsize;        // 当前分配的存储总容量（能容纳多少个ElemType）
} SqList; // SqList 是顺序表的类型名
```

#### **三、顺序表的基本操作及代码实现**

##### **1. 初始化（InitList）**

- **功能**：构造一个空的顺序表，并为其分配初始内存空间。
    
- **代码实现**：
    
    ```
    Status InitList(SqList &L) {
        // 为顺序表分配一个大小为 maxsize 的数组
        L.elem = (ElemType*)malloc(maxsize * sizeof(ElemType));
        if (!L.elem) exit(OVERFLOW); // 内存分配失败
        L.length = 0;      // 空表长度为0
        L.listsize = maxsize; // 初始存储容量
        return OK;
    }
    ```
    
- **时间复杂度**：**O(1)**。
    

##### **2. 按值查找（LocateElem）**

- **功能**：在顺序表 L 中查找第一个与给定值 `e`相等的元素，并返回其**位序**（从1开始），若未找到则返回0。
    
- **代码实现**：
    
    ```
    int LocateElem(SqList L, ElemType e) {
        int i = 1;              // 位序从1开始
        ElemType* p = L.elem;   // 指针p指向第1个元素（下标0）
        while (i <= L.length && *p != e) {
            ++i;
            ++p; // 指针和位序同步后移
        }
        if (i <= L.length) return i; // 找到，返回位序
        else return 0;               // 未找到
    }
    ```
    
- **时间复杂度**：**O(n)**。平均需要比较 `n/2`次。
    

##### **3. 插入操作（ListInsert）**

- **功能**：在位序 `i`（1 ≤ i ≤ n+1）处插入一个新元素 `e`。
    
- **核心步骤**：
    
    1. **判断插入位置 `i`是否合法**。
        
    2. **检查存储空间是否已满**。
        
    3. **将第 i 个至第 n 个元素全部向后移动一个位置**，为新元素腾出空间。
        
    4. 将新元素 `e`放入位置 `i`。
        
    5. 表长 `length`加 1。
        
    
- **代码实现**：
    
    ```
    Status ListInsert(SqList &L, int i, ElemType e) {
        // 1. 判断位置合法性
        if (i < 1 || i > L.length + 1) return ERROR;
        // 2. 判断空间是否已满
        if (L.length >= L.listsize) return OVERFLOW;
        // 3. 移动元素：从最后一个元素开始，到第i个元素结束
        for (int j = L.length - 1; j >= i - 1; --j) {
            L.elem[j + 1] = L.elem[j]; // 将下标为j的元素移到j+1处
        }
        // 4. 插入新元素（注意位序i对应下标i-1）
        L.elem[i - 1] = e;
        // 5. 表长增加
        L.length++;
        return OK;
    }
    ```
    
- **时间复杂度**：**O(n)**。
    
    - **最好情况**：在表尾插入（i = n+1），移动 0 次，O(1)。
        
    - **最坏情况**：在表头插入（i = 1），移动 n 次，O(n)。
        
    - **平均情况**：移动元素的期望值为 **n/2**，故平均时间复杂度为 O(n)。
        
    

##### **4. 删除操作（ListDelete）**

- **功能**：删除位序为 `i`（1 ≤ i ≤ n）的元素，并用 `e`返回其值。
    
- **核心步骤**：
    
    1. **判断删除位置 `i`是否合法**。
        
    2. 将待删除元素的值赋给 `e`（可选，用于返回）。
        
    3. **将第 i+1 个至第 n 个元素全部向前移动一个位置**，覆盖被删除的元素。
        
    4. 表长 `length`减 1。
        
    
- **代码实现**：
    
    ```
    Status ListDelete(SqList &L, int i, ElemType &e) {
        // 1. 判断位置合法性
        if (i < 1 || i > L.length) return ERROR;
        // 2. 保存被删除元素的值
        e = L.elem[i - 1];
        // 3. 移动元素：从第i+1个元素开始，到最后一个元素结束
        for (int j = i; j < L.length; ++j) { // j是位序，对应下标j-1
            L.elem[j - 1] = L.elem[j]; // 将下标为j的元素移到j-1处
        }
        // 4. 表长减少
        L.length--;
        return OK;
    }
    ```
    
- **时间复杂度**：**O(n)**。
    
    - **最好情况**：删除表尾元素（i = n），移动 0 次，O(1)。
        
    - **最坏情况**：删除表头元素（i = 1），移动 n-1 次，O(n)。
        
    - **平均情况**：移动元素的期望值为 **(n-1)/2**，故平均时间复杂度为 O(n)。
        
    

#### **四、顺序表应用实例**

- **问题**：从一个**非空有序**顺序表中删除所有值重复的元素，使所有元素的值均不同。
    
- **算法思想（双指针法）**：
    
    1. 设置一个指针 `k`（可视为新表的末尾），初始指向第一个元素（`k=0`，对应下标0）。
        
    2. 用另一个指针 `i`从第二个元素（`i=1`，对应下标1）开始遍历。
        
    3. 比较 `L.elem[i]`和 `L.elem[k]`：
        
        - 如果**不相等**，说明遇到了一个新值。将 `k`后移一位，然后将 `L.elem[i]`的值赋给 `L.elem[k]`。
            
        - 如果相等，说明是重复值，`i`继续后移，`k`不动。
            
        
    4. 遍历完成后，新表的长度为 `k+1`。
        
    
- **代码实现**：
    
    ```
    void DelSameElem(SqList &L) {
        if (L.length == 0) return; // 空表直接返回
        int k = 0; // k指向非重复序列的最后一个位置
        for (int i = 1; i < L.length; i++) {
            if (L.elem[i] != L.elem[k]) { // 找到新元素
                k++; // k后移
                L.elem[k] = L.elem[i]; // 将新元素放入k的位置
            }
        }
        L.length = k + 1; // 更新表长
    }
    ```
    
- **时间复杂度**：**O(n)**，只需遍历一次顺序表。
    

#### **五、内容小结与要点回顾**

1. **本质**：顺序表是线性表的**数组实现**。
    
2. **优点**：
    
    - **随机存取**：通过位序访问元素的时间复杂度为 **O(1)**，查找效率高。
        
    - **存储密度高**：无需为表示逻辑关系而增加额外的存储开销。
        
    
3. **缺点**：
    
    - **插入/删除操作效率低**：平均需要移动约一半的元素，时间复杂度为 **O(n)**。
        
    - **存储空间不灵活**：需要预先分配固定大小的空间，难以适应数据动态变化。
        
    
4. **适用场景**：适合**查询操作多、增删操作少**，且数据量相对稳定的应用。
    

通过本章学习，应能深刻理解顺序表的优缺点，并熟练掌握其基本操作的实现原理和代码。