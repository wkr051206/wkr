好的，这是对《栈的概念及应用》章节知识点的详细总结，包括所有核心概念、应用场景和算法代码。

---

### **《栈的概念及应用》章节知识点总结**

本章节核心是讲解一种重要的线性结构——**栈**。重点在于理解其 **“后进先出”（LIFO）**​ 的特性，以及它在解决特定问题中的强大应用。

#### **一、栈的定义与核心特性**

1. **定义**：
    
    - 栈是限定**仅在表尾（栈顶）**​ 进行插入（**入栈/Push**）和删除（**出栈/Pop**）操作的**线性表**。
        
    
2. **核心特性：后进先出（LIFO - Last In, First Out）**
    
    - 最后入栈的元素最先出栈。这就像一摞盘子，你总是拿走最上面的那个（最后放上去的）。
        
    
3. **关键术语**：
    
    - **栈顶（Top）**：允许进行插入和删除的一端。
        
    - **栈底（Bottom）**：不允许进行操作的一端。
        
    - **空栈**：不包含任何数据元素的栈。
        
    
4. **本质**：栈是一种**操作受限的线性表**。对比普通线性表，它的插入和删除位置是固定的。
    

#### **二、栈的抽象数据类型（ADT）**

栈的ADT定义了其逻辑特性和基本操作，不关心具体实现（顺序或链式）。

**基本操作**：

- `InitStack(&S)`：**初始化**操作，构造一个空栈 S。
    
- `DestroyStack(&S)`：**销毁**操作，释放栈 S 占用的存储空间。
    
- `ClearStack(&S)`：**清空**操作，将栈 S 重置为空栈。
    
- `StackEmpty(S)`：**判空**操作，若栈 S 为空则返回 TRUE。
    
- `StackLength(S)`：**求长**操作，返回栈 S 的元素个数。
    
- `GetTop(S, &e)`：**取栈顶元素**操作，用 e 返回 S 的栈顶元素（**不删除**）。
    
- `Push(&S, e)`：**入栈**操作，插入元素 e 为新的栈顶元素。
    
- `Pop(&S, &e)`：**出栈**操作，删除 S 的栈顶元素，并用 e 返回其值。
    

#### **三、栈的应用（核心内容）**

栈的“后进先出”特性非常适合于处理需要“就近匹配”或“回溯”的问题。

##### **应用一：数制转换**

- **问题**：将十进制数 `N`转换为八进制数。
    
- **算法思想**：利用“除8取余法”，但计算出的余数是从低位到高位的。而输出需要从高位到低位。栈的LIFO特性正好可以反转顺序。
    
- **算法步骤**：
    
    1. 初始化一个空栈。
        
    2. 循环，当 `N`不为0时：
        
        - 将 `N % 8`的结果入栈。
            
        - 将 `N`更新为 `N / 8`。
            
        
    3. 循环结束后，将栈中元素依次出栈并输出，即得八进制数。
        
    
- **代码实现**：
    
    ```
    void conversion() {
        SqStack S;  // 假设SqStack是已定义好的顺序栈类型
        InitStack(S); // 初始化栈S
        int N, e;
        scanf("%d", &N); // 输入十进制数N
    
        // 1. 计算余数并入栈
        while (N != 0) {
            Push(S, N % 8); // 余数入栈
            N = N / 8;
        }
    
        // 2. 依次出栈并输出，实现顺序反转
        while (!StackEmpty(S)) {
            Pop(S, e); // 出栈
            printf("%d", e); // 输出余数
        }
    }
    ```
    

##### **应用二：括号匹配检验**

- **问题**：检验一个字符串中的括号（如 `()`, `[]`）是否正确地成对匹配。
    
- **算法思想**：
    
    - 遇到**左括号**（`(`, `[`）则**入栈**，表示“期待”一个相应的右括号。
        
    - 遇到**右括号**（`)`, `]`）则检查栈顶的左括号是否与之匹配。
        
        - 若栈空或不匹配，则失败。
            
        - 若匹配，则将栈顶的左括号**出栈**，表示一个匹配完成。
            
        
    - 字符串扫描完后，若栈为空，则匹配成功；否则，说明有左括号多余，匹配失败。
        
    
- **代码实现**：
    
    ```
    int Matching(char exp[], int n) { // exp是表达式字符串，n是其长度
        SqStack S;
        InitStack(S);
        int i = 0;
        int match = 1; // 匹配标志，1成功，0失败
        char e;
    
        while (i < n && match) {
            switch (exp[i]) {
                case '(':
                case '[':
                    Push(S, exp[i]); // 左括号入栈
                    i++;
                    break;
    
                case ')':
                    if (!StackEmpty(S) && GetTop(S, e) && e == '(') {
                        Pop(S, e); // 匹配成功，栈顶'('出栈
                        i++;
                    } else {
                        match = 0; // 栈空或栈顶不匹配，则失败
                    }
                    break;
    
                case ']':
                    if (!StackEmpty(S) && GetTop(S, e) && e == '[') {
                        Pop(S, e); // 匹配成功，栈顶'['出栈
                        i++;
                    } else {
                        match = 0;
                    }
                    break;
    
                default:
                    i++; // 忽略非括号字符
                    break;
            } // end switch
        } // end while
    
        // 最终判断：字符串扫描完且栈为空，才算完全匹配
        if (match && StackEmpty(S)) {
            printf("括弧匹配成功！");
            return 1;
        } else {
            printf("括弧匹配失败！");
            return 0;
        }
    }
    ```
    

##### **应用三：表达式求值（难点与重点）**

- **问题**：计算一个算术表达式（如 `3 + 5 * (4 - 2)`）的值。
    
- **中缀表达式**：运算符在操作数中间（如 `a + b`）。**缺点**：计算顺序不直观，需要括号和优先级规则。
    
- **后缀表达式（逆波兰表示法）**：运算符在操作数后面（如 `a b +`）。**优点**：**无括号**，计算顺序完全由运算符出现顺序决定，非常适合栈处理。
    
    - 中缀 `a + b`对应后缀 `a b +`
        
    - 中缀 `a + b * c`对应后缀 `a b c * +`（先算乘法）
        
    - 中缀 `(a + b) * c`对应后缀 `a b + c *`（括号改变了顺序）
        
    
- **后缀表达式求值算法（利用栈）**：
    
    - **算法步骤**：
        
        1. 初始化一个**操作数栈**。
            
        2. 从左到右扫描后缀表达式：
            
            - 若遇到**操作数**，则将其**入栈**。
                
            - 若遇到**运算符**​ `op`，则连续**出栈**两个操作数（先出栈的是右操作数 `b`，后出栈的是左操作数 `a`），计算 `a op b`的结果，并将结果**入栈**。
                
            
        3. 表达式扫描完后，栈中唯一的元素就是最终结果。
            
        
    - **代码实现（伪代码）**：
        
        ```
        double EvaluatePostfix(char* postfix_exp) {
            SqStack S; // 操作数栈，存储double类型
            InitStack(S);
            int i = 0;
            double a, b, result;
        
            while (postfix_exp[i] != '\0') { // 遍历后缀表达式字符串
                if (IsOperand(postfix_exp[i])) { // 如果是操作数（可能是多位数）
                    // 将字符串转换为数值，然后入栈（此处需具体实现）
                    double operand = StringToDouble(...);
                    Push(S, operand);
                } else if (IsOperator(postfix_exp[i])) { // 如果是运算符
                    Pop(S, b); // 先弹出右操作数
                    Pop(S, a); // 再弹出左操作数
                    switch (postfix_exp[i]) {
                        case '+': result = a + b; break;
                        case '-': result = a - b; break;
                        case '*': result = a * b; break;
                        case '/': result = a / b; break; // 注意除零错误
                    }
                    Push(S, result); // 计算结果入栈
                }
                i++;
            }
            Pop(S, result);
            return result;
        }
        ```
        
    

#### **四、课堂练习：出栈序列的可能性**

- **问题**：三个元素 `a, b, c`依次入栈，问有多少种可能的出栈顺序？
    
- **答案**：可能的出栈序列有5种：`abc`, `acb`, `bac`, `bca`, `cba`。
    
- **不可能**的出栈序列是：`cab`。
    
    - **原因分析**：`c`第一个出栈，意味着 `a, b, c`都已入栈。出栈顺序为 `c`-> `a`-> `b`。但 `a`在 `b`之前入栈，`b`在栈顶，`a`在栈底。要取出 `a`，必须先取出 `b`，所以 `a`不可能在 `b`之前出栈。这体现了栈的LIFO特性。
        
    

#### **五、内容小结**

1. **逻辑结构**：栈是**操作受限的线性表**。
    
2. **核心规则**：**后进先出（LIFO）**。
    
3. **基本操作**：只能在**栈顶**进行插入（`Push`）和删除（`Pop`）。
    
4. **主要应用**：凡是需要“**反转顺序**”、“**状态暂存/回溯**”或“**就近匹配**”的场景，都可考虑使用栈，如：
    
    - 函数调用栈
        
    - 编译原理中的语法分析
        
    - 浏览器的前进/后退功能
        
    - 本文介绍的**数制转换**、**括号匹配**和**表达式求值**。