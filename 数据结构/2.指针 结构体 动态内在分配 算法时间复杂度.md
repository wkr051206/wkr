## 指针与函数
设计一个函数，传入两个int参数，并交换这两个参数的值
```c
#include <stdio.h>
void swap(int *a,int *b)
{
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
    printf("a=%d,b=%d\n",*a,*b)  ;
}
int main(int argc,char const *argv[])
{
    int m=5;
    int n=10;
    swap(&m,&n);//交换了两者的地址
    printf("m=%d,n=%d\n",m,n);
    return 0;
}
```
- 用指针遍历数组：
```c
int a[]={15,22,67,42,87};
int *p;
p=a;
for(int i=0;i<sizeof(a)/sizeof(a[0]);i++)
{
printf("%d\n",*(p+i));// 等价于 a[i]  
  //当i=0时：`*(p+0)`= `*p`= a[0] = 15 
  //当i=1时：`*(p+1)`= a[1] = 22
}
```
## 结构体的声明
结构体是一个或多个变量的集合，这些变量可以是不同的类型(比如：定义一个坐标系，包含x和y)
声明语法：
```c
struct point//结构体名
{
int x;//数据类型（int） 变量名（x）
int y;//数据类型 变量名
}
```

```c
#include<stdio.h>
struct point//先定义这个结构体下面才可以运行
  int x;
  int y;
};
int main(int argc,char const *argv[])
{
  struct point p;
  p.x=5;
  p.y=10;
  printf("%d\n",p.x);
  printf("%d\n",p.y);
  return 0;
  }
```
### 结构体实例-创建一个point
编写一个函数，传入两个int参数，在函数创建一个结构体point类型的变量，将传入的两个参数分别赋值给该结构体变量的x和y，最后将该结构体变量返回。
```c
#include<stdio.h>
struct point// 定义结构体类型 point
{
int x;// 结构体成员，表示x坐标
int y;
};
// 创建point结构体的函数
struct point createPoint(int x,int y)// 接收x和y坐标作为参数
{
struct point temp;// 声明临时point结构体变量
temp.x=x;// 将参数x赋值给临时变量的x成员
temp.y=y;// 将参数y赋值给临时变量的y成员
return temp;// 返回整个结构体（值拷贝）
}
int main(int argc,char const *argv[])// 主函数入口
{
struct point p;// 声明point结构体变量p
p=createPoint(5,10);// 调用函数创建结构体并赋值给p
printf("%d\n",p.x);// 打印p的x坐标值（输出5）
printf("%d\n",p.y);// 打印p的y坐标值（输出10）
return 0;
}
```
## 结构体与指针
在一些场景中，如果传递给函数的结构体很大，使用指针方式的效率通常更高
![](media/Pasted%20image%2020251009083932.png)

```c
#include<stdio.h>

struct point// 定义结构体类型 point
{
int x;
int y;
};

int main(int argc,char const *argv[])
{
  struct point p;  // 创建结构体变量 p
  p.x=5;  // 设置 p 的 x 成员
  p.y=10;  // 设置 p 的 y 成员
  
  struct point *pp;
  pp=&p;  // 将 pp 指向 p 的地址
  (*pp).x=10;  // 通过指针访问结构体成员（方式1：解引用后使用点运算符）
  (*pp).y=5;  // 等价于 p.y = 5
  
  printf("x=%d,y=%d\n",p.x,p.y);  // 直接访问
  printf("x=%d,y=%d\n",pp->x,pp->y); 
  // 通过指针使用箭头运算符访问,代替 (*pp).y = 5,(*pp).x = 10
  
  return 0;
}
```
## 类型定义
![](media/Pasted%20image%2020251009090446.png)
```c
#include<stdio.h>

typedef int myType1;  // 为int类型创建别名myType1
typedef char myType2;  // 为char类型创建别名myType2

int main(int argc,char const *argv[])
{
  // 使用自定义类型别名声明变量
  myType1 a=5;  // 等价于 int a = 5;
  myType2 b='o';  // 等价于 char b = 'o';
  
  printf("%d\n",a);  // 输出整数
  printf("%c\n",b);  // 输出字符
  
  return 0;
}
```

- 每次声明结构体变量都要写struct关键字，很麻烦，逻辑上很难受，typeof可以解决这个问题
![](media/Pasted%20image%2020251009092720.png)
![](media/Pasted%20image%2020251009092931.png)

```c
#include<stdio.h>

typedef struct  // 使用typedef定义结构体别名
{
  int x;
  int y;
}po;  // 'po' 现在是这个结构体类型的别名

int main(int argc,char const *argv[])
{
  po p;  // 使用别名声明结构体变量，不需要写'struct'关键字
  p.x=5;  // 访问结构体成员
  p.y=10;  // 访问结构体成员
  printf("%d\n",p.x);
  printf("%d\n",p.y);
  return 0;
}
```

## 内存分类

C程序编译后，会以三种形式使用内存：

​**​静态/全局内存​**​
静态声明的变量和全局变量使用这部分内存，这些变量在程序开始运行时分配，直到程序终止才消失。

​**​自动内存（栈内存）​**​
函数内部声明的变量使用这部分内存，在函数被调用时才创建。

​**​动态内存（堆内存）​**​
根据需求编写代码动态分配内存，可以编写代码释放，内存中的内容直到释放才消失。

### 动态内存分配
在C语言中，动态分配内存的基本步骤：

1. 使用 malloc（memory allocate）函数分配内存
void* malloc(size_t)
如果成功，会返回从堆内存上分配的内存指针
如果失败，会返回空指针

2. 使用分配的内存

3. 使用 free 函数释放内存

**动态内存分配示例-基本数据类型**

```c
#include<stdio.h>// 包含标准输入输出函数
#include<stdlib.h>// 包含动态内存分配函数(malloc/free)

int main(int argc,char const *argv[])// 主函数入口
{
  int *p;// 声明整型指针变量p（未初始化）
  
  p=(int*)malloc(sizeof(int)); // 动态分配内存：分配一个整型大小的内存块(通常4字节),sizeof(int)就是4字节但是不能用4来代替
  
  *p=15;// 将15存储到分配的内存地址中
  
  printf("%d\n",*p);// 输出指针指向的值（输出15）
  
  free(p);// 释放之前分配的内存，防止内存泄漏
  
  return 0;
}
```

***动态内存分配示例-字符串
```c
#include<stdio.h> // 包含标准输入输出函数
#include<stdlib.h> // 包含动态内存分配函数(malloc/free)
#include<string.h> // 包含字符串操作函数(strcpy)

int main(int argc,char const *argv[]) // 主函数入口
{
char *s; // 声明字符指针变量s（未初始化）

s=(char*)malloc(10);// 动态分配内存：分配10字节的内存空间

strcpy(s,"Hello");
// 将字符串"Hello"复制到分配的内存中
// 注意："Hello"占用6字节（包括结尾的'\0'）

printf("%s\n",s);

return 0;
}
```

***动态内存分配示例-数组
```c
#include<stdio.h> // 包含标准输入输出函数
#include<stdlib.h> // 包含动态内存分配函数(malloc/free)

int main(int argc,char const *argv[])// 主函数入口
{

// 动态分配整型数组：分配5个整数的空间
// 等价于 int arr[5]，但在堆内存中
int *arr=(int*)malloc(5*sizeof(int));

// 初始化数组：将所有元素设为0
for(int i=0;i<5;i++)
{
arr[i]=0;// 等价于 *(arr + i) = 0
}

for(int i=0;i<5;i++)
{
printf("%d\n",arr[i]);// 输出每个元素的值（都是0）
}

free(arr);

return 0;
}
```

***动态内存分配示例-结构体
```c
#include<stdio.h>
#include<stdlib.h>

typedef struct
{
int x;
int y;
}po;// 定义结构体类型别名：po (point的缩写)

int main(int argc,char const *argv[])
{

po *p;// 声明指向po结构体的指针变量p

p=(po*)malloc(sizeof(po));// 动态分配内存：分配一个po结构体大小的空间

p->x=5;// 等价于 (*p).x = 5

p->y=10;// 通过指针访问结构体成员

printf("%d\n",p->x);
printf("%d\n",p->y);
return 0;
}
```

## 算法分析

***算法满足的5个重要特性
- 有穷性
- 确定性
- 可行性
- 输入
- 输出

## 时间复杂度

![](media/Pasted%20image%2020251014140943.png)
最好时间复杂度：算法在最好情况下的的时间复杂度。

最坏时间复杂度：算法在最坏情况下的时间复杂度。

平均时间复杂度：算法在所有可能的情况下，按照输入实例以等概率出现时，算法计量的加权平均值。

对算法时间复杂度的度量，通常只讨论算法在最坏情况下的时间复杂度，即分析在最坏情况下，算法执行时间的上界。

![](media/Pasted%20image%2020251014142127.png)
![](media/Pasted%20image%2020251014143026.png)

![](media/Pasted%20image%2020251014143046.png)

![](media/Pasted%20image%2020251014144147.png)

***例题
![](media/Pasted%20image%2020251014145220.png)

![](media/Pasted%20image%2020251014145819.png)

![](media/Pasted%20image%2020251014150047.png)

![](media/Pasted%20image%2020251014150150.png)![](media/Pasted%20image%2020251014150204.png)
